> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Welcome to Arc

> An open Layer-1 blockchain purpose-built to unite programmable money and onchain innovation with real-world economic activity.

Arc is designed to serve as the Economic OS for the internet, enabling builders
and issuers worldwide to power the next era of onchain lending, capital markets,
FX, and payments, igniting liquidity across currencies and asset classes.

Engineered for mass adoption, Arc is enterprise-grade infrastructure featuring
predictable fiat-based fees using stablecoins as gas (starting with USDC),
deterministic sub-second finality, opt-in configurable privacy, and direct
integration with Circle's full-stack platform for secure access to liquidity and
powerful developer tooling.

As a public EVM-compatible network, developers can deploy smart contracts, build
applications, and transact freely using familiar tools. While validator
participation is permissioned for security and compliance, access to Arc is
fully open.

<Tip>
  Ready to start building? See the [Deploy on Arc](/arc/tutorials/deploy-on-arc)
  quickstart.
</Tip>

## Core principles

Arc is more than a new blockchain. It's a new approach to how global economic
coordination and infrastructure should be built, forged with the same principles
of transparency and trust that define Circle:

<AccordionGroup>
  <Accordion title="Purpose-built, not general-purpose">
    Arc focuses on real-world economic activity, including but not limited to
    global finance, internet commerce, and institutional-grade DeFi.
  </Accordion>

  <Accordion title="Open and composable by default">
    While enterprise-ready, Arc is a public network and open to all developers.
    Anyone can build, transact, integrate, and contribute to the Arc ecosystem.
  </Accordion>

  <Accordion title="Market-neutral and multichain-aligned">
    Arc is interoperable with the broader multichain ecosystem through Circle CCTP
    and Circle Gateway, unlocking new use cases, partners, and institutional
    liquidity onchain.
  </Accordion>

  <Accordion title="Built to coordinate, not control">
    Arc aligns builders and partners across exchanges, market makers, asset
    issuers, fintechs, banks, PSPs, and enterprises to achieve something bigger
    than the sum of their parts.
  </Accordion>

  <Accordion title="Trusted infrastructure, end-to-end">
    Arc is built on Malachite, a highly efficient BFT consensus engine designed
    for certainty, reliability, and long-term operational excellence.
  </Accordion>
</AccordionGroup>

## What you can build

<AccordionGroup>
  <Accordion title="Onchain credit with offchain trust">
    Design credit infrastructure that combines stablecoins with external trust
    signals:

    * **Identity-based lending protocols** using verifiable credentials
    * **Reputation-driven credit systems** tied to cash flow or payment history
    * **SMB and consumer credit apps** serving under-served markets
  </Accordion>

  <Accordion title="Capital markets settlement and tokenized collateral">
    Modernize capital markets with stablecoin-native settlement:

    * **Tokenized securities platforms** with instant DvP
    * **Collateral management systems** for stablecoin-backed margin
    * **Tokenized funds and structured products** issued onchain
    * **Prediction markets** trading real-time data, forecasts, and risk signals
  </Accordion>

  <Accordion title="Stablecoin FX">
    Create markets and services around
    [stablecoin conversion and FX](https://developers.circle.com/stablefx):

    * **Perpetuals and derivatives exchanges** on stablecoin pairs
    * **Swap APIs** for programmatic stablecoin-to-stablecoin conversion
    * **Treasury tools** for multi-currency rebalancing and cross-border payouts
  </Accordion>

  <Accordion title="Agentic commerce">
    Enable autonomous systems to transact natively onchain:

    * **AI-mediated marketplaces** where agents buy, sell, and execute transactions
    * **Machine-to-machine payment networks** for IoT and devices
    * **Coordination systems** for agents to post, match, and settle intents in real
      time
  </Accordion>

  <Accordion title="Cross-border payments and payouts">
    Power global money movement with fiat-backed stablecoins, instant settlement,
    and low fees:

    * **Remittance platforms** for consumer transfers
    * **Payout systems** for marketplaces, gig workers, and global payroll
    * **Trade finance platforms** with tokenized invoices and automated onchain
      settlement
  </Accordion>
</AccordionGroup>


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Welcome to Arc

> An open Layer-1 blockchain purpose-built to unite programmable money and onchain innovation with real-world economic activity.

Arc is designed to serve as the Economic OS for the internet, enabling builders
and issuers worldwide to power the next era of onchain lending, capital markets,
FX, and payments, igniting liquidity across currencies and asset classes.

Engineered for mass adoption, Arc is enterprise-grade infrastructure featuring
predictable fiat-based fees using stablecoins as gas (starting with USDC),
deterministic sub-second finality, opt-in configurable privacy, and direct
integration with Circle's full-stack platform for secure access to liquidity and
powerful developer tooling.

As a public EVM-compatible network, developers can deploy smart contracts, build
applications, and transact freely using familiar tools. While validator
participation is permissioned for security and compliance, access to Arc is
fully open.

<Tip>
  Ready to start building? See the [Deploy on Arc](/arc/tutorials/deploy-on-arc)
  quickstart.
</Tip>

## Core principles

Arc is more than a new blockchain. It's a new approach to how global economic
coordination and infrastructure should be built, forged with the same principles
of transparency and trust that define Circle:

<AccordionGroup>
  <Accordion title="Purpose-built, not general-purpose">
    Arc focuses on real-world economic activity, including but not limited to
    global finance, internet commerce, and institutional-grade DeFi.
  </Accordion>

  <Accordion title="Open and composable by default">
    While enterprise-ready, Arc is a public network and open to all developers.
    Anyone can build, transact, integrate, and contribute to the Arc ecosystem.
  </Accordion>

  <Accordion title="Market-neutral and multichain-aligned">
    Arc is interoperable with the broader multichain ecosystem through Circle CCTP
    and Circle Gateway, unlocking new use cases, partners, and institutional
    liquidity onchain.
  </Accordion>

  <Accordion title="Built to coordinate, not control">
    Arc aligns builders and partners across exchanges, market makers, asset
    issuers, fintechs, banks, PSPs, and enterprises to achieve something bigger
    than the sum of their parts.
  </Accordion>

  <Accordion title="Trusted infrastructure, end-to-end">
    Arc is built on Malachite, a highly efficient BFT consensus engine designed
    for certainty, reliability, and long-term operational excellence.
  </Accordion>
</AccordionGroup>

## What you can build

<AccordionGroup>
  <Accordion title="Onchain credit with offchain trust">
    Design credit infrastructure that combines stablecoins with external trust
    signals:

    * **Identity-based lending protocols** using verifiable credentials
    * **Reputation-driven credit systems** tied to cash flow or payment history
    * **SMB and consumer credit apps** serving under-served markets
  </Accordion>

  <Accordion title="Capital markets settlement and tokenized collateral">
    Modernize capital markets with stablecoin-native settlement:

    * **Tokenized securities platforms** with instant DvP
    * **Collateral management systems** for stablecoin-backed margin
    * **Tokenized funds and structured products** issued onchain
    * **Prediction markets** trading real-time data, forecasts, and risk signals
  </Accordion>

  <Accordion title="Stablecoin FX">
    Create markets and services around
    [stablecoin conversion and FX](https://developers.circle.com/stablefx):

    * **Perpetuals and derivatives exchanges** on stablecoin pairs
    * **Swap APIs** for programmatic stablecoin-to-stablecoin conversion
    * **Treasury tools** for multi-currency rebalancing and cross-border payouts
  </Accordion>

  <Accordion title="Agentic commerce">
    Enable autonomous systems to transact natively onchain:

    * **AI-mediated marketplaces** where agents buy, sell, and execute transactions
    * **Machine-to-machine payment networks** for IoT and devices
    * **Coordination systems** for agents to post, match, and settle intents in real
      time
  </Accordion>

  <Accordion title="Cross-border payments and payouts">
    Power global money movement with fiat-backed stablecoins, instant settlement,
    and low fees:

    * **Remittance platforms** for consumer transfers
    * **Payout systems** for marketplaces, gig workers, and global payroll
    * **Trade finance platforms** with tokenized invoices and automated onchain
      settlement
  </Accordion>
</AccordionGroup>


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Deploy on Arc

> Learn how to deploy, test, and interact with a Solidity smart contract on the Arc Testnet.

<Info>
  Arc is currently in its testnet phase. During this period, the network may
  experience instability or unplanned downtime. **Note:** Throughout this page,
  all references to Arc refer specifically to the Arc Testnet.
</Info>

In this tutorial, you'll use Solidity and Foundry to write, deploy, and interact
with a simple smart contract on the Arc Testnet.

## What you'll learn

By the end of this tutorial, you'll be able to:

* Set up your development environment
* Configure Foundry to connect with Arc
* Implement your smart contract
* Deploy your contract to Arc Testnet
* Interact with your deployed contract

## Set up your development environment

Before you deploy to Arc, you need a working development environment. In this
step, you install [**Foundry**](https://getfoundry.sh/), a portable Ethereum
development toolkit, and initialize a new Solidity project.

1. Install Development Tools

```shell  theme={null}
# Download foundry installer `foundryup`
curl -L https://foundry.paradigm.xyz | bash
```

2. Install binaries

```shell  theme={null}
# Install forge, cast, anvil, chisel
foundryup
```

3. Initialize a new Solidity Project

```shell  theme={null}
forge init hello-arc && cd hello-arc
```

## Configure Foundry to interact with Arc

In this step, you set up Foundry to connect to the Arc network by adding Arc's
RPC URLs to your project environment.

1. Create a `.env` file

Open the `hello-arc` project in your preferred code editor (for example, **VS
Code**). Then, create a new file named `.env` in the root of the project
directory.

2. Add the Arc Testnet RPC URL

Paste the following environment variable into the `.env` file:

```ini  theme={null}
ARC_TESTNET_RPC_URL="https://rpc.testnet.arc.network"
```

This URL allows Foundry to connect to the Arc Testnet.

<Tip>
  Never commit your `.env` file to version control. Store private keys and
  sensitive variables securely.
</Tip>

## Implement your smart contract

In this step, you create the **HelloArchitect** contract, update the test and
script files, and compile the project.

<Info>
  **HelloArchitect** is a simple storage contract that manages a greeting
  message: it starts with a default greeting, lets you update it, and emits an
  event whenever the greeting changes.
</Info>

### 1. Write the HelloArchitect contract

First, delete the default `Counter.sol` template file from the `/src` directory:

```shell  theme={null}
rm src/Counter.sol
```

Next, create a new file named `HelloArchitect.sol` inside the `/src` directory,
and add the following code:

```js  theme={null}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

contract HelloArchitect {
    string private greeting;

    // Event emitted when the greeting is changed
    event GreetingChanged(string newGreeting);

    // Constructor that sets the initial greeting to "Hello Architect!"
    constructor() {
        greeting = "Hello Architect!";
    }

    // Setter function to update the greeting
    function setGreeting(string memory newGreeting) public {
        greeting = newGreeting;
        emit GreetingChanged(newGreeting);
    }

    // Getter function to return the current greeting
    function getGreeting() public view returns (string memory) {
        return greeting;
    }
}
```

This contract includes a private `greeting` variable that stores the greeting
string, along with two public functions:

* `setGreeting` updates the `greeting` value and emits the `GreetingChanged`
  event
* `getGreeting` returns the current value of `greeting`

### 2. Update scripts and tests

Since you deleted `Counter.sol`, you need to remove or replace any scripts and
tests that reference it to avoid compilation errors.

**Delete the `script` directory**

The `script` directory includes files that reference `Counter.sol`. Since you've
removed `Counter.sol`, delete the entire `script` directory to avoid compilation
errors:

```shell  theme={null}
rm -rf script
```

<Tip>
  You can recreate this directory later with updated deployment scripts for your
  own contracts.
</Tip>

**Replace `Counter.t.sol` with `HelloArchitect.t.sol`**

Navigate to the `/test` directory, delete the existing `Counter.t.sol` file, and
create a new test file named `HelloArchitect.t.sol`. Then, add the following
test cases to validate your contract:

```js  theme={null}
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.30;

import "forge-std/Test.sol";
import "../src/HelloArchitect.sol";

contract HelloArchitectTest is Test {
    HelloArchitect helloArchitect;

    function setUp() public {
        helloArchitect = new HelloArchitect();
    }

    function testInitialGreeting() public view {
        string memory expected = "Hello Architect!";
        string memory actual = helloArchitect.getGreeting();
        assertEq(actual, expected);
    }

    function testSetGreeting() public {
        string memory newGreeting = "Welcome to Arc Chain!";
        helloArchitect.setGreeting(newGreeting);
        string memory actual = helloArchitect.getGreeting();
        assertEq(actual, newGreeting);
    }

    function testGreetingChangedEvent() public {
        string memory newGreeting = "Building on Arc!";

        // Expect the GreetingChanged event to be emitted
        vm.expectEmit(true, true, true, true);
        emit HelloArchitect.GreetingChanged(newGreeting);

        helloArchitect.setGreeting(newGreeting);
    }
}
```

### 3. Test the contract

Run the following command to execute the contract's unit tests locally:

```shell  theme={null}
forge test
```

This will compile the project, run the tests defined in `HelloArchitect.t.sol`,
and display the results in your terminal.

### 4. Compile the contract

To compile the **HelloArchitect** contract and generate build artifacts, run:

```shell  theme={null}
forge build
```

This creates the `/out` directory containing the compiled bytecode and ABI,
which you'll use when deploying the contract.

## Deploy your contract to Arc Testnet

In this step, you generate a wallet, fund it with testnet USDC (Arc's native gas
token), and deploy your smart contract to the Arc Testnet using Foundry.

### 1. Generate a wallet

To deploy the **HelloArchitect** contract, you need a funded wallet. Use the
Foundry command-line tool to generate a new wallet:

```shell  theme={null}
cast wallet new
```

The command generates a new keypair and returns output similar to the following:

```
Successfully created new keypair.
Address:     0xB815A0c4bC23930119324d4359dB65e27A846A2d
Private key: 0xcc1b30a6af68ea9a9917f1dd••••••••••••••••••••••••••••••••••••••97c5
```

<Warning>
  **Important:** Keep your private key secure. Never share it or commit it to
  source control.
</Warning>

Add your private key to your `.env` file:

```ini  theme={null}
PRIVATE_KEY="0x..."
```

Reload your environment variables:

```shell  theme={null}
source .env
```

### 2. Fund your wallet

Visit [https://faucet.circle.com](https://faucet.circle.com), select **Arc Testnet**, paste your wallet
address, and request testnet USDC.

Since USDC is Arc's native gas token, this will provide the funds needed to
cover gas fees when deploying your contract.

<Info>
  Testnet USDC is for testing purposes only. It has no real-world value and must
  not be used in production.
</Info>

### 3. Deploy the contract

With your wallet funded with testnet USDC, deploy the **HelloArchitect**
contract to the Arc Testnet using the Foundry command-line tool:

```shell  theme={null}
forge create src/HelloArchitect.sol:HelloArchitect \
  --rpc-url $ARC_TESTNET_RPC_URL \
  --private-key $PRIVATE_KEY \
  --broadcast
```

<Warning>
  **Important:** Never expose your real private key in production. Use
  environment variables or secrets management in real deployments.
</Warning>

After the contract is deployed successfully, you should see output similar to
this:

```
Compiler run successful!
Deployer: 0xB815A0c4bC23930119324d4359dB65e27A846A2d
Deployed to: 0x32368037b14819C9e5Dbe96b3d67C59b8c65c4BF
Transaction hash: 0xeba0fcb5e528d586db0aeb2465a8fad0299330a9773ca62818a1827560a67346
```

### 4. Store the contract address

Copy the deployed contract address from the `Deployed to:` line and save it to
your `.env` file:

```ini  theme={null}
HELLOARCHITECT_ADDRESS="0x..."
```

Reload your environment variables again:

```shell  theme={null}
source .env
```

## Interact with your deployed contract

In this step, you verify that the deployment succeeded by checking the
transaction in the Arc Testnet Explorer, then use `cast` to call a function from
your contract.

### 1. Check transaction on the explorer

Open the [Arc Testnet Explorer](https://testnet.arcscan.app), and paste the
**transaction hash** from the deployment output. This lets you view the
transaction details and confirm that the contract was deployed successfully.

### 2. Use `cast` to call a contract function

Use the `cast call` command to interact with your deployed contract from the
command line. Run the following:

```shell  theme={null}
cast call $HELLOARCHITECT_ADDRESS "getGreeting()(string)" \
  --rpc-url $ARC_TESTNET_RPC_URL
```

The command calls the `getGreeting` function on the **HelloArchitect** contract
and returns the current value of the `greeting` variable.

## Next steps

Congratulations, you've deployed and interacted with your first contract on Arc
Testnet. From here, you can:

* Extend the **HelloArchitect** contract with more logic for additional
  features.
* Explore Arc's stablecoin-native features like USDC as gas and deterministic
  finality
* Build more advanced applications for payments, FX, or tokenized assets


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Connect to Arc

> Connect your wallet or app to the Arc chain network.

## Network details

### Arc Testnet

| Name             | Value                                                                                                                                                                                                                                                                                                                                                                                   |
| :--------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Network**      | Arc Testnet                                                                                                                                                                                                                                                                                                                                                                             |
| **RPC endpoint** | [https://rpc.testnet.arc.network](https://rpc.testnet.arc.network) <br /> Alternatives: <br />   • [https://rpc.blockdaemon.testnet.arc.network](https://rpc.blockdaemon.testnet.arc.network) <br />   • [https://rpc.drpc.testnet.arc.network](https://rpc.drpc.testnet.arc.network) <br />   • [https://rpc.quicknode.testnet.arc.network](https://rpc.quicknode.testnet.arc.network) |
| **WebSocket**    | [wss://rpc.testnet.arc.network](wss://rpc.testnet.arc.network) <br /> Alternatives: <br />   • [wss://rpc.drpc.testnet.arc.network](wss://rpc.drpc.testnet.arc.network) <br />   • [wss://rpc.quicknode.testnet.arc.network](wss://rpc.quicknode.testnet.arc.network)                                                                                                                   |
| **Chain ID**     | 5042002                                                                                                                                                                                                                                                                                                                                                                                 |
| **Currency**     | USDC                                                                                                                                                                                                                                                                                                                                                                                    |
| **Explorer**     | [https://testnet.arcscan.app](https://testnet.arcscan.app)                                                                                                                                                                                                                                                                                                                              |
| **Faucet**       | [https://faucet.circle.com](https://faucet.circle.com)                                                                                                                                                                                                                                                                                                                                  |

## Wallet setup

### Add Arc Testnet

1. Open MetaMask → **Add network** → **Add a network manually**.
2. Fill in:

| Field               | Value                                                              |
| :------------------ | :----------------------------------------------------------------- |
| **Network name**    | Arc Testnet                                                        |
| **New RPC URL**     | [https://rpc.testnet.arc.network](https://rpc.testnet.arc.network) |
| **Chain ID**        | 5042002                                                            |
| **Currency symbol** | USDC                                                               |
| **Explorer URL**    | [https://testnet.arcscan.app](https://testnet.arcscan.app)         |

3. Save, then switch to Arc.

<Tip>
  If your wallet supports **custom gas tokens**, ensure display/decimals for
  USDC (18 decimals) and clearly label fees as USDC.
</Tip>

## Gas and fees

Arc uses USDC as the native gas token. For details on gas configuration and the
current base fee policy, see the [Gas and Fees](/arc/references/gas-and-fees)
page.


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Bridge USDC to Arc

> Learn how to bridge USDC to Arc via CCTP with Bridge Kit

export const BridgeKit = ({chains = []}) => {
  return <CodeGroup>
      {chains.map(chain => {
    const isSolana = chain.chainName?.toLowerCase().includes("solana");
    const sourceAddress = isSolana ? "process.env.SOLANA_WALLET_ADDRESS!" : "process.env.EVM_WALLET_ADDRESS!";
    const sourceComment = isSolana ? "Solana address (developer-controlled)" : "EVM address (developer-controlled)";
    return <CodeBlock key={chain.chainLabel} language="typescript" filename={chain.chainLabel}>
            {`// Import Bridge Kit and the Circle Wallets adapter
import { BridgeKit } from "@circle-fin/bridge-kit";
import { createCircleWalletsAdapter } from "@circle-fin/adapter-circle-wallets";
import { inspect } from "util";

// Initialize the SDK
const kit = new BridgeKit();

const bridgeUSDC = async () => {
  try {
    // Set up the Circle Wallets adapter instance, works for both ecosystems
    const adapter = createCircleWalletsAdapter({
      apiKey: process.env.CIRCLE_API_KEY!,
      entitySecret: process.env.CIRCLE_ENTITY_SECRET!,
    });

    console.log("---------------Starting Bridging---------------");

    // Use the same adapter for the source and destination blockchains
    const result = await kit.bridge({
      from: {
        adapter,
        chain: "${chain.chainName}",
        address: ${sourceAddress}, // ${sourceComment}
      },
      to: {
        adapter,
        chain: "Arc_Testnet",
        address: process.env.EVM_WALLET_ADDRESS!, // EVM address (developer-controlled)
      },
      amount: "1.00",
    });

    console.log("RESULT", inspect(result, false, null, true));
  } catch (err) {
    console.log("ERROR", inspect(err, false, null, true));
  }
};

void bridgeUSDC();`}
          </CodeBlock>;
  })}
    </CodeGroup>;
};

<Info>
  [Cross-Chain Transfer Protocol
  (CCTP)](https://www.circle.com/cross-chain-transfer-protocol) is a
  permissionless onchain utility that facilitates USDC transfers securely
  between supported blockchains via native burning and minting. For more info,
  visit the [CCTP](https://developers.circle.com/cctp) docs.
</Info>

In this tutorial, you’ll use
[Circle’s Bridge Kit](https://developers.circle.com/bridge-kit) to
programmatically transfer USDC from an EVM chain (for example, Ethereum Sepolia)
or Solana Devnet to Arc Testnet with
[Circle Dev-Controlled Wallets](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet).

## Prerequisites

Before you begin, make sure you have:

1. Installed [Node.js v22+](https://nodejs.org/)
2. A [Circle Developer Console](https://console.circle.com) account
3. An API key created in the Console:\
   **Keys → Create a key → API key → Standard Key**
4. Your
   [Entity Secret registered](https://developers.circle.com/wallets/dev-controlled/register-entity-secret)

## Step 1: Set up your project

In this step, you prepare your project and environment.

### 1.1. Create a new project

Create a new directory, navigate to it and initialize a new project.

```shell  theme={null}
# Set up your directory and initialize a Node.js project
mkdir crosschain-transfer
cd crosschain-transfer
npm init -y

# Set up module type
npm pkg set type=module

# Add run script
npm pkg set scripts.start="tsx --env-file=.env index.ts"
```

Install [Bridge Kit](https://www.npmjs.com/package/@circle-fin/bridge-kit),
[Circle Wallets adapter](https://www.npmjs.com/package/@circle-fin/adapter-circle-wallets)
and supporting tools.

```shell  theme={null}
# Install dependencies
npm install @circle-fin/bridge-kit @circle-fin/adapter-circle-wallets

# Install dev dependencies
npm install --save-dev tsx typescript @types/node
```

### 1.2. Initialize and configure the project

This command creates a `tsconfig.json` file:

```bash Shell theme={null}
npx tsc --init
```

Then, edit the `tsconfig.json` file:

```bash Shell theme={null}
# Replace the contents of the generated file
cat <<'EOF' > tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "types": ["node"]
  }
}
EOF
```

### 1.3 Configure environment variables

Create a `.env` file in the project directory with your Circle credentials and
wallet addresses, replacing these placeholders with your own credentials:

* `CIRCLE_API_KEY`: your API key should be either environment-prefixed (for
  example, `TEST_API_KEY:abc123:def456` or `LIVE_API_KEY:xyz:uvw`) or
  base64-encoded strings.
* `YOUR_ENTITY_SECRET`: your entity secret should be 64 lowercase alphanumeric
  characters.
* `YOUR_EVM_WALLET_ADDRESS` and `YOUR_SOLANA_WALLET_ADDRESS` are the wallet
  addresses you control through Circle Wallets. You can fetch the addresses from
  the [Circle Developer Console](https://console.circle.com/) or the
  [list wallets](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/get-wallets)
  endpoint. If you don't have dev-controlled wallets, you will create them in
  [Step 2](#step-2:-set-up-your-wallets).

```bash Shell theme={null}
echo "CIRCLE_API_KEY={YOUR_API_KEY}
CIRCLE_ENTITY_SECRET={YOUR_ENTITY_SECRET}
EVM_WALLET_ADDRESS={YOUR_EVM_WALLET_ADDRESS}
SOLANA_WALLET_ADDRESS={YOUR_SOLANA_WALLET_ADDRESS}" > .env
```

<Warning>
  Important: The API key and Entity Secret are sensitive credentials. Do not
  commit them to version control or share them publicly.
</Warning>

## Step 2: Set up your wallets

In this step, you create two dev-controlled wallets and fund one of them with
testnet tokens to make the transfer. If you already have funded dev-controlled
wallets, skip to [Step 3](#step-3:-bridge-usdc).

### 2.1. Create wallets

Install the
[Circle Wallets SDK](https://www.npmjs.com/package/@circle-fin/developer-controlled-wallets).
It is also possible to
[call the API directly](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/)
if you can't use the SDK in your project.

```shell  theme={null}
npm install @circle-fin/developer-controlled-wallets
```

Import the Wallets SDK and initialize the client using your API key and Entity
Secret. Dev-controlled wallets are created in a
[wallet set](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet#1-create-a-wallet-set),
which serves as the source from which individual wallet keys are derived.

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

const client = initiateDeveloperControlledWalletsClient({
  apiKey: "<YOUR_API_KEY>",
  entitySecret: "<YOUR_ENTITY_SECRET>",
});

// Create a wallet set
const walletSetResponse = await client.createWalletSet({
  name: "Wallet Set 1",
});

// Create a wallet on Arc Testnet
const walletsResponse = await client.createWallets({
  blockchains: ["ARC-TESTNET", "SOL-DEVNET"],
  count: 1,
  walletSetId: walletSetResponse.data?.walletSet?.id ?? "",
});
```

<Note>
  If you are calling the API directly, you'll need
  to make two requests: one to [create the wallet set](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet-set); one to [create the wallet](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet).

  Be sure to replace the
  [Entity Secret ciphertext](https://developers.circle.com/wallets/dev-controlled/entity-secret-management#what-is-an-entity-secret-ciphertext)￼
  and the idempotency key in your request. If you are using the SDKs, this is
  automatically taken care of for you.
</Note>

You should now have two new Externally Owned Account (EOA) developer-controlled
wallets that you can also see from the
[Circle Developer Console](https://console.circle.com/wallets/dev/wallets). The
API response will look similar to the following:

```shell  theme={null}
[
  {
    id: "cd8a3a9a-ed17-5e9b-8f6b-7b01a0f27478",
    state: "LIVE",
    walletSetId: "1bb349fd-99dd-50a1-999b-05901533a98d",
    custodyType: "DEVELOPER",
    address: "0xb0b70e1d3599e84fcd61915c023ea12a843506b0",
    blockchain: "ARC-TESTNET",
    accountType: "EOA",
    updateDate: "2026-01-07T06:45:43Z",
    createDate: "2026-01-07T06:45:43Z",
  }, {
    id: "1557b6cf-3d54-5738-84ec-1ceba833e27b",
    state: "LIVE",
    walletSetId: "1bb349fd-99dd-50a1-999b-05901533a98d",
    custodyType: "DEVELOPER",
    address: "DGJ1oZtR7Nk1AidTeKYs1b557dJHHXKBNdVDem7uHDN8",
    blockchain: "SOL-DEVNET",
    accountType: "EOA",
    updateDate: "2026-01-07T06:45:43Z",
    createDate: "2026-01-07T06:45:43Z",
  }
]
```

### 2.2. Fund a wallet with testnet tokens

Obtain testnet USDC from the [Circle Faucet](https://faucet.circle.com/) and
native tokens from the [Console Faucet](https://console.circle.com/faucet) to
pay gas fees. You'll need a funded balance to execute transactions using your
dev-controlled wallet.

### 2.3. Check the wallet's balance

You can check your wallets' balance from the
[Developer Console](https://console.circle.com/wallets/dev/wallets) or
programmatically by making a request to
[GET /wallets/\{id}/balances](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/list-wallet-balance)
with the specified wallet ID.

<CodeGroup>
  ```ts Node.js theme={null}
  const response = await client.getWalletTokenBalance({
    id: "<WALLET_ID>",
  });
  ```

  ```shell cURL theme={null}
  curl --request GET \
       --url 'https://api.circle.com/v1/w3s/wallets/{<WALLET_ID>}/balances' \
       --header 'accept: application/json' \
       --header 'authorization: Bearer <YOUR_API_KEY>'
  ```
</CodeGroup>

## Step 3: Bridge USDC

In this step, you set up your script, execute the bridge transfer, and check the
result.

### 3.1. Create the script

Create an `index.ts` file in the project directory and add the following code.
This code sets up your script and transfers 1 USDC from your chosen chain to Arc
Testnet. It also listens to
[bridge events](https://developers.circle.com/bridge-kit/references/event-handling)
that occur during the transfer lifecycle.

<BridgeKit
  chains={[
  {
    chainLabel: "Arbitrum",
    chainName: "Arbitrum_Sepolia",
  },
  {
    chainLabel: "Avalanche",
    chainName: "Avalanche_Fuji",
  },
  {
    chainLabel: "Base",
    chainName: "Base_Sepolia",
  },
  {
    chainLabel: "Ethereum",
    chainName: "Ethereum_Sepolia",
  },
  {
    chainLabel: "Optimism",
    chainName: "Optimism_Sepolia",
  },
  {
    chainLabel: "Polygon",
    chainName: "Polygon_Amoy_Testnet",
  },
  {
    chainLabel: "Solana",
    chainName: "Solana_Devnet",
  },
  {
    chainLabel: "Unichain",
    chainName: "Unichain_Sepolia",
  },
]}
/>

### 3.2. Run the script

Save the `index.ts` file and run the script in your terminal:

```shell  theme={null}
npm run start
```

<Note>
  For blockchains other than Arc, you will need native tokens to pay for gas.
  The **approve** and **burn** steps require gas fees in the native token of the
  source chain, while the **mint** step requires gas fees in the native token of
  the destination chain.
</Note>

### 3.3. Verify the transfer

After the script finishes, locate the returned `steps` array in the terminal
output. Each transaction step includes an `explorerUrl` field. Use that URL to
verify that the USDC amount matches the amount you transferred.

The following example shows how all four steps (Approve, Burn, Fetch
Attestation, Mint) might look like in the terminal output. The values shown are
for demonstration purposes only and don't represent a real transaction:

<CodeGroup>
  ```shell Approve theme={null}
  {
    name: 'approve',
    state: 'success',
    txHash: '0x809cd6678785c3cb48d73a8e35e5ef8fc21c1b1e22df767860bc30bd882fb470',
    data: {
      txHash: '0x809cd6678785c3cb48d73a8e35e5ef8fc21c1b1e22df767860bc30bd882fb470',
      status: 'success',
      cumulativeGasUsed: 429183n,
      gasUsed: 38596n,
      blockNumber: 20523074n,
      blockHash: '0x5d81b5abab77f19fb3e70df620276fe9b4be68172482afa0188296ead97c3033',
      transactionIndex: 5,
      effectiveGasPrice: 162000000000n
    },
    explorerUrl: 'https://testnet.arcscan.app/tx/0x809cd6678785c3cb48d73a8e35e5ef8fc21c1b1e22df767860bc30bd882fb470'
  }
  ```

  ```shell Burn theme={null}
  {
    name: 'burn',
    state: 'success',
    txHash: '0xab2f6be2bbf651198292eb9db7bb4409d0987778fcfe245a79967354d13cbdfa',
    data: {
      txHash: '0xab2f6be2bbf651198292eb9db7bb4409d0987778fcfe245a79967354d13cbdfa',
      status: 'success',
      cumulativeGasUsed: 275599n,
      gasUsed: 189627n,
      blockNumber: 20523097n,
      blockHash: '0x1ec79eaf235899f777bfb22847ff5b77da60dade2980a95ca6764a2117c62b39',
      transactionIndex: 1,
      effectiveGasPrice: 162000000000n
    },
    explorerUrl: 'https://testnet.arcscan.app/tx/0xab2f6be2bbf651198292eb9db7bb4409d0987778fcfe245a79967354d13cbdfa'
  }
  ```

  ```shell Fetch Attestation theme={null}
  {
    name: 'fetchAttestation',
    state: 'success',
    data: {
      attestation: '0x0b63184157eb3eb07d4a34feec1daa11de018c12f4df99901a3e010f542ae5e2714e533a18ec3993b030e89e6261345ccfaca3818c8e27fc754c7b23ae491a171bacb23b892875657b7a6cfa6efa49b48d43138a475f89bd33c693c46793499d5117bf3a71fdb069b34ea5f4dc2f1d03ef1b5995add2569d6eaa61af657417e1a91c',
      message: '0x000000010000001a00000005b45cbddbbb54fb6fa0edc3c76d36a628fb671cc523beb22e0391086f701c36990000000000000000000000008fe6b999dc680ccfdd5bf7eb0974218be2542daaa65fc81d0fefa8860cb3b83f089b0224be8a6687b7ae49f594c0b9b4d7e938930000000000000000000000000000000000000000000000000000000000000000000003e8000007d0000000010000000000000000000000003600000000000000000000000000000000000000b58d47742ed08e3cf13ccc8b264d4abf435719fb2b2fc4ccf12a9884a24d9b3800000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000c5567a5e3370d4dbfb0540025078e283e36a363d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
      eventNonce: '0xb45cbddbbb54fb6fa0edc3c76d36a628fb671cc523beb22e0391086f701c3699',
      cctpVersion: 2,
      status: 'complete',
      decodedMessage: {
        sourceDomain: '26',
        destinationDomain: '5',
        nonce: '0xb45cbddbbb54fb6fa0edc3c76d36a628fb671cc523beb22e0391086f701c3699',
        sender: '0x8fe6b999dc680ccfdd5bf7eb0974218be2542daa',
        recipient: 'CCTPV2vPZJS2u2BBsUoscuikbYjnpFmbFsvVuJdgUMQe',
        destinationCaller: '11111111111111111111111111111111',
        minFinalityThreshold: '1000',
        finalityThresholdExecuted: '2000',
        messageBody: '0x000000010000000000000000000000003600000000000000000000000000000000000000b58d47742ed08e3cf13ccc8b264d4abf435719fb2b2fc4ccf12a9884a24d9b3800000000000000000000000000000000000000000000000000000000000f4240000000000000000000000000c5567a5e3370d4dbfb0540025078e283e36a363d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000',
        decodedMessageBody: {
          burnToken: '0x3600000000000000000000000000000000000000',
          mintRecipient: 'DDhjzc3iKXvYWM3Nzf96yEFSeWwi1CakZVN4QcgCsa7R',
          amount: '1000000',
          messageSender: '0xc5567a5e3370d4dbfb0540025078e283e36a363d',
          maxFee: '0',
          feeExecuted: '0',
          expirationBlock: '0',
          hookData: null
        }
      },
      delayReason: null
    }
  }
  ```

  ```shell Mint theme={null}
  {
    name: 'mint',
    state: 'success',
    txHash: '2umsQPUCveTU4v82jjNyUviLFPTDZ875GCztK7rZPrpMQnqCDqX2s53o5verAraghtirU1PjoQJhDKaFGWW2PvG',
    data: {
      txHash: '2umsQPUCveTU4v82jjNyUviLFPTDZ875GCztK7rZPrpMQnqCDqX2s53o5verAraghtirU1PjoQJhDKaFGWW2PvG',
      status: 'success',
      gasUsed: 5000n,
      cumulativeGasUsed: 0n,
      blockNumber: 433658235n,
      blockHash: 'confirmed',
      transactionIndex: 0,
      effectiveGasPrice: 5000n
    },
    explorerUrl: 'https://solscan.io/tx/2umsQPUCveTU4v82jjNyUviLFPTDZ875GCztK7rZPrpMQnqCDqX2s53o5verAraghtirU1PjoQJhDKaFGWW2PvG?cluster=devnet'
  }
  ```
</CodeGroup>

***

## Summary

After completing this tutorial, you've successfully:

* Created dev-controlled wallets
* Funded your wallet with testnet USDC
* Bridged USDC from one chain to another


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Access USDC Crosschain

> Learn how to create a unified USDC balance with Gateway and transfer to wallets on Gateway supported chains

In this tutorial, you’ll use
[Circle Gateway](https://developers.circle.com/gateway) to create a
chain-abstracted USDC balance and
[Circle Dev-Controlled Wallets](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet).

## Prerequisites

Before you begin, make sure you have:

1. Installed [Node.js v22+](https://nodejs.org/)
2. A [Circle Developer Console](https://console.circle.com) account
3. An API key created in the Console:\
   **Keys → Create a key → API key → Standard Key**
4. Your
   [Entity Secret registered](https://developers.circle.com/wallets/dev-controlled/register-entity-secret)
   for your wallet (you need it for the script below)

## Step 1: Set up your project

In this step, you prepare your project and environment.

### 1.1. Create a new project

Create a new directory, navigate to it and initialize a new project.

```shell  theme={null}
# Set up your directory and initialize a Node.js project
mkdir unified-gateway-balance
cd unified-gateway-balance
npm init -y

# Set up module type
npm pkg set type=module

# Add run scripts for deposit, transfer, and check balances
npm pkg set scripts.deposit="tsx --env-file=.env deposit.ts"
npm pkg set scripts.transfer="tsx --env-file=.env transfer.ts"
npm pkg set scripts.balances="tsx --env-file=.env balances.ts"
```

Install the
[Circle Dev-Controlled Wallets SDK](https://www.npmjs.com/package/@circle-fin/developer-controlled-wallets)
and supporting tools. It is also possible to
[call the API directly](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/)
if you can't use the SDK in your project.

```shell  theme={null}
# Install dependencies
npm install @circle-fin/developer-controlled-wallets

# Install dev dependencies
npm install --save-dev tsx typescript @types/node
```

### 1.2. Initialize and configure the project

This command creates a `tsconfig.json` file:

```bash Shell theme={null}
npx tsc --init
```

Then, edit the `tsconfig.json` file:

```bash Shell theme={null}
# Replace the contents of the generated file
cat <<'EOF' > tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "types": ["node"]
  }
}
EOF
```

### 1.3 Configure environment variables

Create a `.env` file in the project directory with your Circle credentials,
replacing these placeholders with your own credentials:

* `CIRCLE_API_KEY`: your API key should be either environment-prefixed (for
  example, `TEST_API_KEY:abc123:def456` or `LIVE_API_KEY:xyz:uvw`) or
  base64-encoded strings.
* `CIRCLE_ENTITY_SECRET`: your entity secret should be 64 lowercase alphanumeric
  characters.

```shell  theme={null}
echo "CIRCLE_API_KEY={YOUR_API_KEY}
CIRCLE_ENTITY_SECRET={YOUR_ENTITY_SECRET}" > .env
```

<Warning>
  Important: These are sensitive credentials. Do not commit them to version
  control or share them publicly.
</Warning>

## Step 2: Set up your wallets

In this step, you create dev-controlled wallets and fund them with USDC and
native tokens to make a deposit into a unified Gateway balance. If you already
have funded dev-controlled wallets, skip to
[Step 3](#step-3:-deposit-into-a-unified-crosschain-balance).

### 2.1. Create wallets on supported chains

Import the Circle Wallets SDK and initialize the client using your API key and
Entity Secret. Dev-controlled wallets are created in a
[wallet set](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet#1-create-a-wallet-set),
which serves as the source from which individual wallet keys are derived.

<Note>
  If you supply a `refId`, all EVM wallets sharing that `refId` in the function
  call will [have the same
  address](https://developers.circle.com/wallets/unified-wallet-addressing-evm#batch-create-wallets-across-supported-chains).
  Having the same address across all the blockchains makes it more
  straightforward when depositing funds with the [`deposit`
  function](https://developers.circle.com/gateway/references/contract-interfaces-and-events#deposit).
</Note>

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

const client = initiateDeveloperControlledWalletsClient({
  apiKey: "<YOUR_API_KEY>",
  entitySecret: "<YOUR_ENTITY_SECRET>",
});

// Create a wallet set
const walletSetResponse = await client.createWalletSet({
  name: "Gateway Source Wallets",
});

// Create wallets on supported chains
const walletsResponse = await client.createWallets({
  blockchains: ["ARC-TESTNET", "AVAX-FUJI", "BASE-SEPOLIA", "ETH-SEPOLIA"],
  count: 1,
  walletSetId: walletSetResponse.data?.walletSet?.id ?? "",
  metadata: [{ refId: "source-depositor" }],
});
```

<Note>
  If you're calling the API directly, you'll need
  to make two requests: one to [create the wallet set](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet-set); one to [create the wallet](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet).

  Be sure to replace the
  [Entity Secret ciphertext](https://developers.circle.com/wallets/dev-controlled/entity-secret-management#what-is-an-entity-secret-ciphertext)￼
  and the idempotency key in your request. If you're using the SDKs, this is
  handled automatically for you.
</Note>

You should now have four new Externally Owned Account (EOA) developer-controlled
wallets with the same wallet address that you can also see from the
[Developer Console](https://console.circle.com/wallets/dev/wallets). The API
response will look similar to the following:

```shell  theme={null}
[
  {
    id: "d646ea32-818d-50e2-85d6-473f809c9f24",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "ARC-TESTNET",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }, {
    id: "4be20092-b475-551a-a24f-b698e73c078d",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "AVAX-FUJI",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }, {
    id: "ec2cd72c-e799-5fa7-95f1-08e1a62a1b1a",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "BASE-SEPOLIA",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }, {
    id: "1b93227b-7721-5f27-a825-ffbc46cf92fc",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "ETH-SEPOLIA",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }
]
```

Add your wallet IDs to the `.env` file. These values will be used in the deposit
and transfer scripts described in the following sections.

```shell  theme={null}
cat >> .env << 'EOF'

ETH_SEPOLIA_WALLET_ID={YOUR_ETH_SEPOLIA_WALLET_ID}
BASE_SEPOLIA_WALLET_ID={YOUR_BASE_SEPOLIA_WALLET_ID}
AVAX_FUJI_WALLET_ID={YOUR_AVAX_FUJI_WALLET_ID}
ARC_TESTNET_WALLET_ID={YOUR_ARC_TESTNET_WALLET_ID}
EOF
```

### 2.2. Add testnet funds to your wallet

To interact with Gateway, you need test USDC and native tokens in your wallet on
each chain you deposit from. You also need testnet native tokens on the
destination chain to call the Gateway Minter contract.

Use the [Circle Faucet](https://faucet.circle.com/) to get testnet USDC and the
[Console Faucet](https://console.circle.com/faucet) to get testnet native
tokens. In addition, the following faucets can also be used to fund your wallet
with testnet native tokens:

<Tabs>
  <Tab title="Arc">
    **Faucet:** [Arc Testnet](https://faucet.circle.com) (USDC + native tokens)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `arcTestnet`                                 |
    | USDC address | `0x3600000000000000000000000000000000000000` |
    | Domain ID    | `26`                                         |
  </Tab>

  <Tab title="Avalanche">
    **Faucet:** [Avalanche Fuji](https://core.app/tools/testnet-faucet)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `avalancheFuji`                              |
    | USDC address | `0x5425890298aed601595a70ab815c96711a31bc65` |
    | Domain ID    | `1`                                          |
  </Tab>

  <Tab title="Base">
    **Faucet:** [Base Sepolia](https://www.alchemy.com/faucets/base-sepolia)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `baseSepolia`                                |
    | USDC address | `0x036CbD53842c5426634e7929541eC2318f3dCF7e` |
    | Domain ID    | `6`                                          |
  </Tab>

  <Tab title="Ethereum">
    **Faucet:** [Ethereum Sepolia](https://cloud.google.com/application/web3/faucet/ethereum/sepolia)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `sepolia`                                    |
    | USDC address | `0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238` |
    | Domain ID    | `0`                                          |
  </Tab>
</Tabs>

To request more testnet USDC, you can fill out this
[Testnet USDC Faucet Survey](https://docs.google.com/forms/d/e/1FAIpQLSfxt9OFA4I2v6Jp7u_4R4mdfitOkXqGZYeXBe10foCS1nEJkg/viewform).

### 2.3. Check wallet balances

You can check your wallet balances from the
[Circle Developer Console](https://console.circle.com/wallets/dev/wallets) or
programmatically by making a request to
[GET /wallets/\{id}/balances](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/list-wallet-balance)
with the specified wallet ID.

<CodeGroup>
  ```ts Node.js theme={null}
  const response = await client.getWalletTokenBalance({
    id: "<WALLET_ID>",
  });
  ```

  ```shell cURL theme={null}
  curl --request GET \
       --url 'https://api.circle.com/v1/w3s/wallets/{<WALLET_ID>}/balances' \
       --header 'accept: application/json' \
       --header 'authorization: Bearer <YOUR_API_KEY>'
  ```
</CodeGroup>

## Step 3: Deposit into a unified crosschain balance

In this step, you review each part of the script to deposit USDC into the
Gateway Wallet contracts. You can skip to the
[full deposit script](#3-6-full-deposit-script) if you prefer.

### 3.1. Create the script file

```shell  theme={null}
touch deposit.ts
```

### 3.2. Define chain configuration

```ts  theme={null}
type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
  },
};
```

### 3.3. Define constants

```ts  theme={null}
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSIT_AMOUNT_USDC = "2";
```

### 3.4. Add helper functions

```ts  theme={null}
// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run deposit -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run deposit -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}
```

### 3.5. Approve and deposit USDC

The main logic performs two key actions:

* **Approve USDC transfers:** It calls the `approve` method on the USDC contract
  to allow the Gateway Wallet contract to transfer USDC from your wallet.
* **Deposit USDC into Gateway:** After receiving the approval transaction hash,
  it calls the `deposit` method on the Gateway Wallet contract.

<Note>
  **Important:** You must call the `deposit` method, not the standard `transfer`
  function on the USDC contract. Deposits into the Gateway Wallet only work
  through the designated `deposit` function.
</Note>

```ts  theme={null}
async function main() {
  // Allows for chain selection via CLI arguments
  const selectedChains = parseSelectedChains();
  console.log(
    `Depositing to: ${selectedChains.map((chain) => CHAIN_CONFIG[chain].chainName).join(", ")}`,
  );

  // Initiate wallets client
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });

  // Process each selected chain
  for (const chain of selectedChains) {
    const config = CHAIN_CONFIG[chain];
    const USDC_ADDRESS = config.usdc;
    const WALLET_ID = config.walletId;

    console.log(`\n--- ${config.chainName} ---`);

    // Approve USDC for the Gateway Wallet to transfer USDC from your address
    console.log(
      `Approving ${DEPOSIT_AMOUNT_USDC} USDC for spender ${GATEWAY_WALLET_ADDRESS}`,
    );

    const approveTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: USDC_ADDRESS,
      abiFunctionSignature: "approve(address,uint256)",
      abiParameters: [
        GATEWAY_WALLET_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const approveTxId = approveTx.data?.id;
    if (!approveTxId) throw new Error("Failed to create approve transaction");

    await waitForTxCompletion(client, approveTxId, "USDC approve");

    // Call deposit method on the Gateway Wallet contract
    console.log(`Depositing ${DEPOSIT_AMOUNT_USDC} USDC to Gateway Wallet`);

    const depositTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: GATEWAY_WALLET_ADDRESS,
      abiFunctionSignature: "deposit(address,uint256)",
      abiParameters: [
        USDC_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const depositTxId = depositTx.data?.id;
    if (!depositTxId) throw new Error("Failed to create deposit transaction");

    await waitForTxCompletion(client, depositTxId, "Gateway deposit");
  }

  console.log(
    "Transaction complete. Once finality is reached, Gateway credits your unified USDC balance.",
  );
}

main().catch((error) => {
  console.error("\nError:", error?.response?.data ?? error);
  process.exit(1);
});
```

### 3.6. Full deposit script

Now that you've completed the setup and core steps, this full script brings
everything together. It deposits 2 USDC from the specified chain into your
Gateway balance. The script includes inline comments to explain what each
function does, making it easier to follow and modify if needed.

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

/* Chain configuration */
type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
  },
};

/* Constants */
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSIT_AMOUNT_USDC = "5";

/* Helpers */
// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run deposit -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run deposit -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}

/* Main logic */
async function main() {
  // Allows for chain selection via CLI arguments
  const selectedChains = parseSelectedChains();
  console.log(
    `Depositing to: ${selectedChains.map((chain) => CHAIN_CONFIG[chain].chainName).join(", ")}`,
  );

  // Initiate wallets client
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });

  // Process each selected chain
  for (const chain of selectedChains) {
    const config = CHAIN_CONFIG[chain];
    const USDC_ADDRESS = config.usdc;
    const WALLET_ID = config.walletId;

    console.log(`\n--- ${config.chainName} ---`);

    // Approve USDC for the Gateway Wallet to transfer USDC from your address
    console.log(
      `Approving ${DEPOSIT_AMOUNT_USDC} USDC for spender ${GATEWAY_WALLET_ADDRESS}`,
    );

    const approveTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: USDC_ADDRESS,
      abiFunctionSignature: "approve(address,uint256)",
      abiParameters: [
        GATEWAY_WALLET_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const approveTxId = approveTx.data?.id;
    if (!approveTxId) throw new Error("Failed to create approve transaction");

    await waitForTxCompletion(client, approveTxId, "USDC approve");

    // Call deposit method on the Gateway Wallet contract
    console.log(`Depositing ${DEPOSIT_AMOUNT_USDC} USDC to Gateway Wallet`);

    const depositTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: GATEWAY_WALLET_ADDRESS,
      abiFunctionSignature: "deposit(address,uint256)",
      abiParameters: [
        USDC_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const depositTxId = depositTx.data?.id;
    if (!depositTxId) throw new Error("Failed to create deposit transaction");

    await waitForTxCompletion(client, depositTxId, "Gateway deposit");
  }

  console.log(
    "Transaction complete. Once finality is reached, Gateway credits your unified USDC balance.",
  );
}

main().catch((error) => {
  console.error("\nError:", error?.response?.data ?? error);
  process.exit(1);
});
```

### 3.7. Run the script to create a crosschain balance

Run the `deposit` script to make the deposits. You can select which chain to
deposit from using command-line arguments.

```shell  theme={null}
# Deposit to all chains
npm run deposit

# Deposit to a single chain
npm run deposit -- base

# Deposit to multiple chains
npm run deposit -- base avalanche
```

Wait for the
[required number of block confirmations](https://developers.circle.com/gateway/references/supported-blockchains#required-block-confirmations).
Once the deposit transactions are final, the total balance is the sum of all the
USDC from deposit transactions across all supported chains that have reached
finality. Note that for certain chains, finality may take up to 20 minutes to be
reached.

### 3.8. Check the balances on the Gateway Wallet

Create a new file called `balances.ts`, and add the following code. This script
retrieves the USDC balances available from your Gateway Wallet on each supported
chain. You can run it to check whether finality has been reached for recent
transactions.

```shell  theme={null}
touch balances.ts
```

Replace the placeholder `<WALLET_ID>` in the `main()` function with any of the
wallet IDs from the created wallets. The code derives the address from the
wallet ID provided.

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

const GATEWAY_API = "https://gateway-api-testnet.circle.com/v1";

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const CHAINS = {
  ethereum: { domain: 0, name: "Ethereum Sepolia" },
  avalanche: { domain: 1, name: "Avalanche Fuji" },
  base: { domain: 6, name: "Base Sepolia" },
  arc: { domain: 26, name: "Arc Testnet" },
};
const chainList = Object.values(CHAINS);
const domainNames = Object.fromEntries(
  chainList.map((chain) => [chain.domain, chain.name]),
);

const toBigInt = (value: string | number | null | undefined): bigint => {
  const balanceString = String(value ?? "0");
  if (balanceString.includes(".")) {
    const [whole, decimal = ""] = balanceString.split(".");
    const decimal6 = (decimal + "000000").slice(0, 6);
    return BigInt((whole || "0") + decimal6);
  }
  return BigInt(balanceString || "0");
};

async function showUnifiedAvailableBalance(client: any, walletId: string) {
  const { data } = await client.getWallet({ id: walletId });
  const depositor = data?.wallet?.address;
  if (!depositor) throw new Error("Could not resolve wallet address");
  console.log(`Depositor address: ${depositor}`);

  // Query Gateway for the available balance recorded by the system
  const response = await fetch(`${GATEWAY_API}/balances`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      token: "USDC",
      sources: chainList.map(({ domain }) => ({ domain, depositor })),
    }),
  });
  const { balances = [] } = await response.json();

  let totalBalances = 0n;
  for (const balance of balances) {
    const amount = toBigInt(balance?.balance);
    const chain =
      domainNames[balance!.domain as number] ??
      `Domain ${balance!.domain as number}`;
    console.log(
      `  - ${chain}: ${amount / 1_000_000n}.${(amount % 1_000_000n)
        .toString()
        .padStart(6, "0")} USDC`,
    );
    totalBalances += amount;
  }
  const whole = totalBalances / 1_000_000n;
  const decimal = totalBalances % 1_000_000n;
  const totalUsdc = `${whole}.${decimal.toString().padStart(6, "0")}`;
  console.log(`Unified USDC available: ${totalUsdc} USDC`);
}

async function main() {
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });
  const walletId = "<WALLET_ID>";
  await showUnifiedAvailableBalance(client, walletId);
}

main().catch((error) => {
  console.error("\n Error:", error?.response?.data ?? error);
  process.exit(1);
});
```

Run the script to check the unified balance.

```shell  theme={null}
npm run balances
```

## Step 4: Transfer USDC from the crosschain balance to Arc

In this step, you can review the transfer script, covering configuration,
approval, and minting USDC on Arc from your crosschain balance. You can skip to
the [full transfer script](#4-8-full-transfer-script) if you prefer.

### 4.1. Create the script file

```shell  theme={null}
touch transfer.ts
```

### 4.2. Define chain configuration

```ts  theme={null}
type WalletChain = "ETH-SEPOLIA" | "BASE-SEPOLIA" | "AVAX-FUJI" | "ARC-TESTNET";

type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
  domain: number;
  walletChain: WalletChain;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
    domain: 0,
    walletChain: "ETH-SEPOLIA",
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
    domain: 6,
    walletChain: "BASE-SEPOLIA",
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
    domain: 1,
    walletChain: "AVAX-FUJI",
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
    domain: 26,
    walletChain: "ARC-TESTNET",
  },
};
```

### 4.3. Define constants and EIP-712 typed data types

These constants define the parameters for transferring funds from your Gateway
balance to a wallet on the destination chain.

* Replace the `<WALLET_ADDRESS>` placeholder with the unified wallet address of
  your created dev-controlled wallets. You can run the `balances.ts` script to
  check the balance.
* The `DESTINATION_CHAIN` is currently set to `BASE-SEPOLIA` but you can change
  it to a chain of your choice. Note that
  [gas fees](https://developers.circle.com/gateway/references/fees#table-of-fees)
  differ between chains.
* Replace the `<RECIPIENT_ADDRESS>` placeholder with a wallet address on the
  destination chain.
* You can set the amount of USDC to be transfered from each chain within the
  unified balance, which is currently set to 1 USDC.

```ts  theme={null}
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";
const GATEWAY_MINTER_ADDRESS = "0x0022222ABE238Cc2C7Bb1f21003F0a260052475B";
const MAX_UINT256_DEC = ((1n << 256n) - 1n).toString();

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSITOR_ADDRESS = "<WALLET_ADDRESS>";
const DESTINATION_CHAIN: WalletChain = "<DESTINATION_CHAIN>"; // "ETH-SEPOLIA" | "BASE-SEPOLIA" | "AVAX-FUJI" | "ARC-TESTNET"
const RECIPIENT_ADDRESS = "<RECIPIENT_ADDRESS>";
const TRANSFER_AMOUNT_USDC = 1;

/* Burn intent and EIP-712 definitions */
type BurnIntentSpec = {
  version: number;
  sourceDomain: number;
  destinationDomain: number;
  sourceContract: string;
  destinationContract: string;
  sourceToken: string;
  destinationToken: string;
  sourceDepositor: string;
  destinationRecipient: string;
  sourceSigner: string;
  destinationCaller: string;
  value: bigint;
  salt: string;
  hookData: string;
};

type BurnIntentType = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: BurnIntentSpec;
};

type EIP712DomainType = {
  name: string;
  version: string;
};

type TypedDataMessage = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: {
    version: number;
    sourceDomain: number;
    destinationDomain: number;
    sourceContract: string;
    destinationContract: string;
    sourceToken: string;
    destinationToken: string;
    sourceDepositor: string;
    destinationRecipient: string;
    sourceSigner: string;
    destinationCaller: string;
    value: bigint;
    salt: string;
    hookData: string;
  };
};

type SignedBurnIntentRequest = {
  burnIntent: TypedDataMessage;
  signature: string | undefined;
};

const EIP712Domain = [
  { name: "name", type: "string" },
  { name: "version", type: "string" },
];

const TransferSpec = [
  { name: "version", type: "uint32" },
  { name: "sourceDomain", type: "uint32" },
  { name: "destinationDomain", type: "uint32" },
  { name: "sourceContract", type: "bytes32" },
  { name: "destinationContract", type: "bytes32" },
  { name: "sourceToken", type: "bytes32" },
  { name: "destinationToken", type: "bytes32" },
  { name: "sourceDepositor", type: "bytes32" },
  { name: "destinationRecipient", type: "bytes32" },
  { name: "sourceSigner", type: "bytes32" },
  { name: "destinationCaller", type: "bytes32" },
  { name: "value", type: "uint256" },
  { name: "salt", type: "bytes32" },
  { name: "hookData", type: "bytes" },
];

const BurnIntent = [
  { name: "maxBlockHeight", type: "uint256" },
  { name: "maxFee", type: "uint256" },
  { name: "spec", type: "TransferSpec" },
];
```

### 4.4. Add helper functions

```ts  theme={null}
// Construct burn intent for a given source chain
function makeBurnIntent(sourceChain: Chain) {
  const src = CHAIN_CONFIG[sourceChain];
  const dst = getConfigByWalletChain(DESTINATION_CHAIN);
  const value = parseBalance(String(TRANSFER_AMOUNT_USDC));

  return {
    maxBlockHeight: MAX_UINT256_DEC,
    maxFee: 2_010000n,
    spec: {
      version: 1,
      sourceDomain: src.domain,
      destinationDomain: dst.domain,
      sourceContract: GATEWAY_WALLET_ADDRESS,
      destinationContract: GATEWAY_MINTER_ADDRESS,
      sourceToken: src.usdc,
      destinationToken: dst.usdc,
      sourceDepositor: DEPOSITOR_ADDRESS,
      destinationRecipient: RECIPIENT_ADDRESS,
      sourceSigner: DEPOSITOR_ADDRESS,
      destinationCaller: addressToBytes32(
        "0x0000000000000000000000000000000000000000",
      ),
      value: value,
      salt: "0x" + randomBytes(32).toString("hex"),
      hookData: "0x",
    },
  };
}

// Format burn intent as EIP-712 typed data for signing
function burnIntentTypedData(
  burnIntent: BurnIntentType,
  domain: EIP712DomainType,
) {
  return {
    types: { EIP712Domain, TransferSpec, BurnIntent },
    domain,
    primaryType: "BurnIntent",
    message: {
      ...burnIntent,
      spec: {
        ...burnIntent.spec,
        sourceContract: addressToBytes32(burnIntent.spec.sourceContract),
        destinationContract: addressToBytes32(
          burnIntent.spec.destinationContract,
        ),
        sourceToken: addressToBytes32(burnIntent.spec.sourceToken),
        destinationToken: addressToBytes32(burnIntent.spec.destinationToken),
        sourceDepositor: addressToBytes32(burnIntent.spec.sourceDepositor),
        destinationRecipient: addressToBytes32(
          burnIntent.spec.destinationRecipient,
        ),
        sourceSigner: addressToBytes32(burnIntent.spec.sourceSigner),
        destinationCaller: addressToBytes32(
          burnIntent.spec.destinationCaller ??
            addressToBytes32("0x0000000000000000000000000000000000000000"),
        ),
      },
    },
  };
}

// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Look up chain configuration by wallet chain
function getConfigByWalletChain(walletChain: WalletChain) {
  const entry = Object.values(CHAIN_CONFIG).find(
    (item) => item.walletChain === walletChain,
  );
  if (!entry) {
    throw new Error(`No config found for destination chain ${walletChain}`);
  }
  return entry;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run transfer -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run transfer -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Pad address to 32 bytes
function addressToBytes32(address: string) {
  return ("0x" +
    address
      .toLowerCase()
      .replace(/^0x/, "")
      .padStart(64, "0")) as `0x${string}`;
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}

// Format base units to decimal: 10500000n → "10.5"
function formatUnits(value: bigint, decimals: number) {
  let display = value.toString();

  const negative = display.startsWith("-");
  if (negative) display = display.slice(1);

  display = display.padStart(decimals, "0");

  const integer = display.slice(0, display.length - decimals);
  let fraction = display.slice(display.length - decimals);

  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// Serialize typed data (convert bigints to strings)
function stringifyTypedData<T>(obj: T) {
  return JSON.stringify(obj, (_key, value) =>
    typeof value === "bigint" ? value.toString() : value,
  );
}
```

### 4.5. Construct and sign the burn intents

First, within the main logic, you need to build the requests and sign them
before they can be submitted to the Gateway API.

```ts  theme={null}
const requests: any[] = [];
const burnIntentsForTotal: any[] = [];

for (const chain of selectedChains) {
  const config = CHAIN_CONFIG[chain];

  const burnIntent = makeBurnIntent(chain);
  const typedData = burnIntentTypedData(burnIntent, domain);

  const sigResp = await client.signTypedData({
    walletId: config.walletId,
    data: stringifyTypedData(typedData),
  });

  requests.push({
    burnIntent: typedData.message,
    signature: sigResp.data?.signature,
  });

  burnIntentsForTotal.push(burnIntent);
}
```

### 4.6. Submit the burn intents to the API

Then, you use the signed burn intents to request an attestation from the Gateway
API.

```ts  theme={null}
const response = await fetch(
  "https://gateway-api-testnet.circle.com/v1/transfer",
  {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(requests, (_key, value) =>
      typeof value === "bigint" ? value.toString() : value,
    ),
  },
);

const json = await response.json();
const attestation = json?.attestation;
const operatorSig = json?.signature;

if (!attestation || !operatorSig) {
  console.error("Gateway /transfer error:", json);
  process.exit(1);
}
```

### 4.7. Mint USDC on destination chain

Finally, you need to pass the attestation to mint USDC to the destination chain
by calling `gatewayMint()` on the Gateway Minter contract.

```ts  theme={null}
const tx = await client.createContractExecutionTransaction({
  walletAddress: DEPOSITOR_ADDRESS,
  blockchain: DESTINATION_CHAIN,
  contractAddress: GATEWAY_MINTER_ADDRESS,
  abiFunctionSignature: "gatewayMint(bytes,bytes)",
  abiParameters: [attestation, operatorSig],
  fee: { type: "level", config: { feeLevel: "MEDIUM" } },
});

console.log("Mint tx submitted:", tx.data?.id);

const txId = tx.data?.id;
if (!txId) throw new Error("Failed to submit mint transaction");
await waitForTxCompletion(client, txId, "USDC mint");

const totalMintBaseUnits = burnIntentsForTotal.reduce(
  (sum, i) => sum + (i.spec.value ?? 0n),
  0n,
);
console.log(`Minted ${formatUnits(totalMintBaseUnits, 6)} USDC`);
```

### 4.8. Full transfer script

Now that you've covered the setup and core steps, this full script puts
everything together and transfers out 1 USDC from each specified Gateway
balances to the destination address. It includes comments that describe what
each function does as well for reference.

```ts  theme={null}
import { randomBytes } from "node:crypto";
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

/* Chain configuration */
type WalletChain = "ETH-SEPOLIA" | "BASE-SEPOLIA" | "AVAX-FUJI" | "ARC-TESTNET";

type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
  domain: number;
  walletChain: WalletChain;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
    domain: 0,
    walletChain: "ETH-SEPOLIA",
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
    domain: 6,
    walletChain: "BASE-SEPOLIA",
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
    domain: 1,
    walletChain: "AVAX-FUJI",
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
    domain: 26,
    walletChain: "ARC-TESTNET",
  },
};

/* Constants */
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";
const GATEWAY_MINTER_ADDRESS = "0x0022222ABE238Cc2C7Bb1f21003F0a260052475B";
const MAX_UINT256_DEC = ((1n << 256n) - 1n).toString();

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSITOR_ADDRESS = "0xd02419296ef08a575e6dea178950e9c9c25126b8";
const DESTINATION_CHAIN: WalletChain = "AVAX-FUJI";
const RECIPIENT_ADDRESS = "0x8b4ac46d9267e25f4d40092b33aedc150ebe5cdf";
const TRANSFER_AMOUNT_USDC = 1;

/* Burn intent and EIP-712 definitions */
type BurnIntentSpec = {
  version: number;
  sourceDomain: number;
  destinationDomain: number;
  sourceContract: string;
  destinationContract: string;
  sourceToken: string;
  destinationToken: string;
  sourceDepositor: string;
  destinationRecipient: string;
  sourceSigner: string;
  destinationCaller: string;
  value: bigint;
  salt: string;
  hookData: string;
};

type BurnIntentType = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: BurnIntentSpec;
};

type EIP712DomainType = {
  name: string;
  version: string;
};

type TypedDataMessage = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: {
    version: number;
    sourceDomain: number;
    destinationDomain: number;
    sourceContract: string;
    destinationContract: string;
    sourceToken: string;
    destinationToken: string;
    sourceDepositor: string;
    destinationRecipient: string;
    sourceSigner: string;
    destinationCaller: string;
    value: bigint;
    salt: string;
    hookData: string;
  };
};

type SignedBurnIntentRequest = {
  burnIntent: TypedDataMessage;
  signature: string | undefined;
};

const EIP712Domain = [
  { name: "name", type: "string" },
  { name: "version", type: "string" },
];

const TransferSpec = [
  { name: "version", type: "uint32" },
  { name: "sourceDomain", type: "uint32" },
  { name: "destinationDomain", type: "uint32" },
  { name: "sourceContract", type: "bytes32" },
  { name: "destinationContract", type: "bytes32" },
  { name: "sourceToken", type: "bytes32" },
  { name: "destinationToken", type: "bytes32" },
  { name: "sourceDepositor", type: "bytes32" },
  { name: "destinationRecipient", type: "bytes32" },
  { name: "sourceSigner", type: "bytes32" },
  { name: "destinationCaller", type: "bytes32" },
  { name: "value", type: "uint256" },
  { name: "salt", type: "bytes32" },
  { name: "hookData", type: "bytes" },
];

const BurnIntent = [
  { name: "maxBlockHeight", type: "uint256" },
  { name: "maxFee", type: "uint256" },
  { name: "spec", type: "TransferSpec" },
];

/* Helpers */
// Construct burn intent for a given source chain
function makeBurnIntent(sourceChain: Chain) {
  const src = CHAIN_CONFIG[sourceChain];
  const dst = getConfigByWalletChain(DESTINATION_CHAIN);
  const value = parseBalance(String(TRANSFER_AMOUNT_USDC));

  return {
    maxBlockHeight: MAX_UINT256_DEC,
    maxFee: 2_010000n,
    spec: {
      version: 1,
      sourceDomain: src.domain,
      destinationDomain: dst.domain,
      sourceContract: GATEWAY_WALLET_ADDRESS,
      destinationContract: GATEWAY_MINTER_ADDRESS,
      sourceToken: src.usdc,
      destinationToken: dst.usdc,
      sourceDepositor: DEPOSITOR_ADDRESS,
      destinationRecipient: RECIPIENT_ADDRESS,
      sourceSigner: DEPOSITOR_ADDRESS,
      destinationCaller: addressToBytes32(
        "0x0000000000000000000000000000000000000000",
      ),
      value: value,
      salt: "0x" + randomBytes(32).toString("hex"),
      hookData: "0x",
    },
  };
}

// Format burn intent as EIP-712 typed data for signing
function burnIntentTypedData(
  burnIntent: BurnIntentType,
  domain: EIP712DomainType,
) {
  return {
    types: { EIP712Domain, TransferSpec, BurnIntent },
    domain,
    primaryType: "BurnIntent",
    message: {
      ...burnIntent,
      spec: {
        ...burnIntent.spec,
        sourceContract: addressToBytes32(burnIntent.spec.sourceContract),
        destinationContract: addressToBytes32(
          burnIntent.spec.destinationContract,
        ),
        sourceToken: addressToBytes32(burnIntent.spec.sourceToken),
        destinationToken: addressToBytes32(burnIntent.spec.destinationToken),
        sourceDepositor: addressToBytes32(burnIntent.spec.sourceDepositor),
        destinationRecipient: addressToBytes32(
          burnIntent.spec.destinationRecipient,
        ),
        sourceSigner: addressToBytes32(burnIntent.spec.sourceSigner),
        destinationCaller: addressToBytes32(
          burnIntent.spec.destinationCaller ??
            addressToBytes32("0x0000000000000000000000000000000000000000"),
        ),
      },
    },
  };
}

// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Look up chain configuration by wallet chain
function getConfigByWalletChain(walletChain: WalletChain) {
  const entry = Object.values(CHAIN_CONFIG).find(
    (item) => item.walletChain === walletChain,
  );
  if (!entry) {
    throw new Error(`No config found for destination chain ${walletChain}`);
  }
  return entry;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run transfer -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run transfer -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Pad address to 32 bytes
function addressToBytes32(address: string) {
  return ("0x" +
    address
      .toLowerCase()
      .replace(/^0x/, "")
      .padStart(64, "0")) as `0x${string}`;
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}

// Format base units to decimal: 10500000n → "10.5"
function formatUnits(value: bigint, decimals: number) {
  let display = value.toString();

  const negative = display.startsWith("-");
  if (negative) display = display.slice(1);

  display = display.padStart(decimals, "0");

  const integer = display.slice(0, display.length - decimals);
  let fraction = display.slice(display.length - decimals);

  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// Serialize typed data (convert bigints to strings)
function stringifyTypedData<T>(obj: T) {
  return JSON.stringify(obj, (_key, value) =>
    typeof value === "bigint" ? value.toString() : value,
  );
}

/* Main logic */
async function main() {
  // Allows for chain selection via CLI arguments
  const selectedChains = parseSelectedChains();
  console.log(
    `Transfering balances from: ${selectedChains.map((c) => CHAIN_CONFIG[c].chainName).join(", ")}`,
  );

  // Initiate wallets client
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });

  const domain = { name: "GatewayWallet", version: "1" };

  // Build requests only for selected chains
  const requests: SignedBurnIntentRequest[] = [];
  const burnIntentsForTotal: BurnIntentType[] = [];

  for (const chain of selectedChains) {
    const config = CHAIN_CONFIG[chain];

    const burnIntent = makeBurnIntent(chain);
    const typedData = burnIntentTypedData(burnIntent, domain);

    const sigResp = await client.signTypedData({
      walletId: config.walletId,
      data: stringifyTypedData(typedData),
    });

    requests.push({
      burnIntent: typedData.message,
      signature: sigResp.data?.signature,
    });

    burnIntentsForTotal.push(burnIntent);
  }

  // Submit burn intents to Gateway API to obtain an attestation
  const response = await fetch(
    "https://gateway-api-testnet.circle.com/v1/transfer",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requests, (_key, value) =>
        typeof value === "bigint" ? value.toString() : value,
      ),
    },
  );

  const json = await response.json();
  const attestation = json?.attestation;
  const operatorSig = json?.signature;

  if (!attestation || !operatorSig) {
    console.error("Gateway /transfer error:", json);
    process.exit(1);
  }

  // Mint on the destination chain
  const tx = await client.createContractExecutionTransaction({
    walletAddress: DEPOSITOR_ADDRESS,
    blockchain: DESTINATION_CHAIN,
    contractAddress: GATEWAY_MINTER_ADDRESS,
    abiFunctionSignature: "gatewayMint(bytes,bytes)",
    abiParameters: [attestation, operatorSig],
    fee: { type: "level", config: { feeLevel: "MEDIUM" } },
  });

  console.log("Mint tx submitted:", tx.data?.id);

  const txId = tx.data?.id;
  if (!txId) throw new Error("Failed to submit mint transaction");
  await waitForTxCompletion(client, txId, "USDC mint");

  const totalMintBaseUnits = burnIntentsForTotal.reduce(
    (sum, i) => sum + (i.spec.value ?? 0n),
    0n,
  );
  console.log(`Minted ${formatUnits(totalMintBaseUnits, 6)} USDC`);
}

main().catch((error) => {
  console.error("\nError:", error?.response?.data ?? error);
  process.exit(1);
});
```

### 4.9. Run the script to transfer USDC to destination chain

Run the `transfer` script to transfer 1 USDC from each selected Gateway balance
to the destination chain.

<Note>
  [Gateway gas fees](https://developers.circle.com/gateway/references/fees) are
  charged per burn intent. To reduce overall gas costs, consider keeping most
  Gateway funds on low-cost chains, where Circle's base fee for burns is
  cheaper.
</Note>

```shell  theme={null}
# Transfer from all chains
npm run transfer

# Transfer from a single chain
npm run transfer -- base

# Transfer from multiple chains
npm run transfer -- ethereum avalanche
```

## Summary

After completing this tutorial, you've successfully:

* Created dev-controlled wallets
* Funded your wallet with testnet USDC
* Created a unified USDC balance
* Transferred USDC out from your unified USDC balance


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Access USDC Crosschain

> Learn how to create a unified USDC balance with Gateway and transfer to wallets on Gateway supported chains

In this tutorial, you’ll use
[Circle Gateway](https://developers.circle.com/gateway) to create a
chain-abstracted USDC balance and
[Circle Dev-Controlled Wallets](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet).

## Prerequisites

Before you begin, make sure you have:

1. Installed [Node.js v22+](https://nodejs.org/)
2. A [Circle Developer Console](https://console.circle.com) account
3. An API key created in the Console:\
   **Keys → Create a key → API key → Standard Key**
4. Your
   [Entity Secret registered](https://developers.circle.com/wallets/dev-controlled/register-entity-secret)
   for your wallet (you need it for the script below)

## Step 1: Set up your project

In this step, you prepare your project and environment.

### 1.1. Create a new project

Create a new directory, navigate to it and initialize a new project.

```shell  theme={null}
# Set up your directory and initialize a Node.js project
mkdir unified-gateway-balance
cd unified-gateway-balance
npm init -y

# Set up module type
npm pkg set type=module

# Add run scripts for deposit, transfer, and check balances
npm pkg set scripts.deposit="tsx --env-file=.env deposit.ts"
npm pkg set scripts.transfer="tsx --env-file=.env transfer.ts"
npm pkg set scripts.balances="tsx --env-file=.env balances.ts"
```

Install the
[Circle Dev-Controlled Wallets SDK](https://www.npmjs.com/package/@circle-fin/developer-controlled-wallets)
and supporting tools. It is also possible to
[call the API directly](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/)
if you can't use the SDK in your project.

```shell  theme={null}
# Install dependencies
npm install @circle-fin/developer-controlled-wallets

# Install dev dependencies
npm install --save-dev tsx typescript @types/node
```

### 1.2. Initialize and configure the project

This command creates a `tsconfig.json` file:

```bash Shell theme={null}
npx tsc --init
```

Then, edit the `tsconfig.json` file:

```bash Shell theme={null}
# Replace the contents of the generated file
cat <<'EOF' > tsconfig.json
{
  "compilerOptions": {
    "target": "ESNext",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "strict": true,
    "types": ["node"]
  }
}
EOF
```

### 1.3 Configure environment variables

Create a `.env` file in the project directory with your Circle credentials,
replacing these placeholders with your own credentials:

* `CIRCLE_API_KEY`: your API key should be either environment-prefixed (for
  example, `TEST_API_KEY:abc123:def456` or `LIVE_API_KEY:xyz:uvw`) or
  base64-encoded strings.
* `CIRCLE_ENTITY_SECRET`: your entity secret should be 64 lowercase alphanumeric
  characters.

```shell  theme={null}
echo "CIRCLE_API_KEY={YOUR_API_KEY}
CIRCLE_ENTITY_SECRET={YOUR_ENTITY_SECRET}" > .env
```

<Warning>
  Important: These are sensitive credentials. Do not commit them to version
  control or share them publicly.
</Warning>

## Step 2: Set up your wallets

In this step, you create dev-controlled wallets and fund them with USDC and
native tokens to make a deposit into a unified Gateway balance. If you already
have funded dev-controlled wallets, skip to
[Step 3](#step-3:-deposit-into-a-unified-crosschain-balance).

### 2.1. Create wallets on supported chains

Import the Circle Wallets SDK and initialize the client using your API key and
Entity Secret. Dev-controlled wallets are created in a
[wallet set](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet#1-create-a-wallet-set),
which serves as the source from which individual wallet keys are derived.

<Note>
  If you supply a `refId`, all EVM wallets sharing that `refId` in the function
  call will [have the same
  address](https://developers.circle.com/wallets/unified-wallet-addressing-evm#batch-create-wallets-across-supported-chains).
  Having the same address across all the blockchains makes it more
  straightforward when depositing funds with the [`deposit`
  function](https://developers.circle.com/gateway/references/contract-interfaces-and-events#deposit).
</Note>

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

const client = initiateDeveloperControlledWalletsClient({
  apiKey: "<YOUR_API_KEY>",
  entitySecret: "<YOUR_ENTITY_SECRET>",
});

// Create a wallet set
const walletSetResponse = await client.createWalletSet({
  name: "Gateway Source Wallets",
});

// Create wallets on supported chains
const walletsResponse = await client.createWallets({
  blockchains: ["ARC-TESTNET", "AVAX-FUJI", "BASE-SEPOLIA", "ETH-SEPOLIA"],
  count: 1,
  walletSetId: walletSetResponse.data?.walletSet?.id ?? "",
  metadata: [{ refId: "source-depositor" }],
});
```

<Note>
  If you're calling the API directly, you'll need
  to make two requests: one to [create the wallet set](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet-set); one to [create the wallet](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet).

  Be sure to replace the
  [Entity Secret ciphertext](https://developers.circle.com/wallets/dev-controlled/entity-secret-management#what-is-an-entity-secret-ciphertext)￼
  and the idempotency key in your request. If you're using the SDKs, this is
  handled automatically for you.
</Note>

You should now have four new Externally Owned Account (EOA) developer-controlled
wallets with the same wallet address that you can also see from the
[Developer Console](https://console.circle.com/wallets/dev/wallets). The API
response will look similar to the following:

```shell  theme={null}
[
  {
    id: "d646ea32-818d-50e2-85d6-473f809c9f24",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "ARC-TESTNET",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }, {
    id: "4be20092-b475-551a-a24f-b698e73c078d",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "AVAX-FUJI",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }, {
    id: "ec2cd72c-e799-5fa7-95f1-08e1a62a1b1a",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "BASE-SEPOLIA",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }, {
    id: "1b93227b-7721-5f27-a825-ffbc46cf92fc",
    state: "LIVE",
    walletSetId: "116e0d3e-4f6d-5f2f-8f34-b119732fce0b",
    custodyType: "DEVELOPER",
    refId: "source-depositor",
    name: "",
    address: "0x7f6f2263e451756456a87e9d6911db22617becf5",
    blockchain: "ETH-SEPOLIA",
    accountType: "EOA",
    updateDate: "2026-01-07T10:07:50Z",
    createDate: "2026-01-07T10:07:50Z",
  }
]
```

Add your wallet IDs to the `.env` file. These values will be used in the deposit
and transfer scripts described in the following sections.

```shell  theme={null}
cat >> .env << 'EOF'

ETH_SEPOLIA_WALLET_ID={YOUR_ETH_SEPOLIA_WALLET_ID}
BASE_SEPOLIA_WALLET_ID={YOUR_BASE_SEPOLIA_WALLET_ID}
AVAX_FUJI_WALLET_ID={YOUR_AVAX_FUJI_WALLET_ID}
ARC_TESTNET_WALLET_ID={YOUR_ARC_TESTNET_WALLET_ID}
EOF
```

### 2.2. Add testnet funds to your wallet

To interact with Gateway, you need test USDC and native tokens in your wallet on
each chain you deposit from. You also need testnet native tokens on the
destination chain to call the Gateway Minter contract.

Use the [Circle Faucet](https://faucet.circle.com/) to get testnet USDC and the
[Console Faucet](https://console.circle.com/faucet) to get testnet native
tokens. In addition, the following faucets can also be used to fund your wallet
with testnet native tokens:

<Tabs>
  <Tab title="Arc">
    **Faucet:** [Arc Testnet](https://faucet.circle.com) (USDC + native tokens)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `arcTestnet`                                 |
    | USDC address | `0x3600000000000000000000000000000000000000` |
    | Domain ID    | `26`                                         |
  </Tab>

  <Tab title="Avalanche">
    **Faucet:** [Avalanche Fuji](https://core.app/tools/testnet-faucet)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `avalancheFuji`                              |
    | USDC address | `0x5425890298aed601595a70ab815c96711a31bc65` |
    | Domain ID    | `1`                                          |
  </Tab>

  <Tab title="Base">
    **Faucet:** [Base Sepolia](https://www.alchemy.com/faucets/base-sepolia)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `baseSepolia`                                |
    | USDC address | `0x036CbD53842c5426634e7929541eC2318f3dCF7e` |
    | Domain ID    | `6`                                          |
  </Tab>

  <Tab title="Ethereum">
    **Faucet:** [Ethereum Sepolia](https://cloud.google.com/application/web3/faucet/ethereum/sepolia)

    | Property     | Value                                        |
    | ------------ | -------------------------------------------- |
    | Chain name   | `sepolia`                                    |
    | USDC address | `0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238` |
    | Domain ID    | `0`                                          |
  </Tab>
</Tabs>

To request more testnet USDC, you can fill out this
[Testnet USDC Faucet Survey](https://docs.google.com/forms/d/e/1FAIpQLSfxt9OFA4I2v6Jp7u_4R4mdfitOkXqGZYeXBe10foCS1nEJkg/viewform).

### 2.3. Check wallet balances

You can check your wallet balances from the
[Circle Developer Console](https://console.circle.com/wallets/dev/wallets) or
programmatically by making a request to
[GET /wallets/\{id}/balances](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/list-wallet-balance)
with the specified wallet ID.

<CodeGroup>
  ```ts Node.js theme={null}
  const response = await client.getWalletTokenBalance({
    id: "<WALLET_ID>",
  });
  ```

  ```shell cURL theme={null}
  curl --request GET \
       --url 'https://api.circle.com/v1/w3s/wallets/{<WALLET_ID>}/balances' \
       --header 'accept: application/json' \
       --header 'authorization: Bearer <YOUR_API_KEY>'
  ```
</CodeGroup>

## Step 3: Deposit into a unified crosschain balance

In this step, you review each part of the script to deposit USDC into the
Gateway Wallet contracts. You can skip to the
[full deposit script](#3-6-full-deposit-script) if you prefer.

### 3.1. Create the script file

```shell  theme={null}
touch deposit.ts
```

### 3.2. Define chain configuration

```ts  theme={null}
type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
  },
};
```

### 3.3. Define constants

```ts  theme={null}
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSIT_AMOUNT_USDC = "2";
```

### 3.4. Add helper functions

```ts  theme={null}
// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run deposit -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run deposit -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}
```

### 3.5. Approve and deposit USDC

The main logic performs two key actions:

* **Approve USDC transfers:** It calls the `approve` method on the USDC contract
  to allow the Gateway Wallet contract to transfer USDC from your wallet.
* **Deposit USDC into Gateway:** After receiving the approval transaction hash,
  it calls the `deposit` method on the Gateway Wallet contract.

<Note>
  **Important:** You must call the `deposit` method, not the standard `transfer`
  function on the USDC contract. Deposits into the Gateway Wallet only work
  through the designated `deposit` function.
</Note>

```ts  theme={null}
async function main() {
  // Allows for chain selection via CLI arguments
  const selectedChains = parseSelectedChains();
  console.log(
    `Depositing to: ${selectedChains.map((chain) => CHAIN_CONFIG[chain].chainName).join(", ")}`,
  );

  // Initiate wallets client
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });

  // Process each selected chain
  for (const chain of selectedChains) {
    const config = CHAIN_CONFIG[chain];
    const USDC_ADDRESS = config.usdc;
    const WALLET_ID = config.walletId;

    console.log(`\n--- ${config.chainName} ---`);

    // Approve USDC for the Gateway Wallet to transfer USDC from your address
    console.log(
      `Approving ${DEPOSIT_AMOUNT_USDC} USDC for spender ${GATEWAY_WALLET_ADDRESS}`,
    );

    const approveTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: USDC_ADDRESS,
      abiFunctionSignature: "approve(address,uint256)",
      abiParameters: [
        GATEWAY_WALLET_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const approveTxId = approveTx.data?.id;
    if (!approveTxId) throw new Error("Failed to create approve transaction");

    await waitForTxCompletion(client, approveTxId, "USDC approve");

    // Call deposit method on the Gateway Wallet contract
    console.log(`Depositing ${DEPOSIT_AMOUNT_USDC} USDC to Gateway Wallet`);

    const depositTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: GATEWAY_WALLET_ADDRESS,
      abiFunctionSignature: "deposit(address,uint256)",
      abiParameters: [
        USDC_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const depositTxId = depositTx.data?.id;
    if (!depositTxId) throw new Error("Failed to create deposit transaction");

    await waitForTxCompletion(client, depositTxId, "Gateway deposit");
  }

  console.log(
    "Transaction complete. Once finality is reached, Gateway credits your unified USDC balance.",
  );
}

main().catch((error) => {
  console.error("\nError:", error?.response?.data ?? error);
  process.exit(1);
});
```

### 3.6. Full deposit script

Now that you've completed the setup and core steps, this full script brings
everything together. It deposits 2 USDC from the specified chain into your
Gateway balance. The script includes inline comments to explain what each
function does, making it easier to follow and modify if needed.

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

/* Chain configuration */
type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
  },
};

/* Constants */
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSIT_AMOUNT_USDC = "5";

/* Helpers */
// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run deposit -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run deposit -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}

/* Main logic */
async function main() {
  // Allows for chain selection via CLI arguments
  const selectedChains = parseSelectedChains();
  console.log(
    `Depositing to: ${selectedChains.map((chain) => CHAIN_CONFIG[chain].chainName).join(", ")}`,
  );

  // Initiate wallets client
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });

  // Process each selected chain
  for (const chain of selectedChains) {
    const config = CHAIN_CONFIG[chain];
    const USDC_ADDRESS = config.usdc;
    const WALLET_ID = config.walletId;

    console.log(`\n--- ${config.chainName} ---`);

    // Approve USDC for the Gateway Wallet to transfer USDC from your address
    console.log(
      `Approving ${DEPOSIT_AMOUNT_USDC} USDC for spender ${GATEWAY_WALLET_ADDRESS}`,
    );

    const approveTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: USDC_ADDRESS,
      abiFunctionSignature: "approve(address,uint256)",
      abiParameters: [
        GATEWAY_WALLET_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const approveTxId = approveTx.data?.id;
    if (!approveTxId) throw new Error("Failed to create approve transaction");

    await waitForTxCompletion(client, approveTxId, "USDC approve");

    // Call deposit method on the Gateway Wallet contract
    console.log(`Depositing ${DEPOSIT_AMOUNT_USDC} USDC to Gateway Wallet`);

    const depositTx = await client.createContractExecutionTransaction({
      walletId: WALLET_ID!,
      contractAddress: GATEWAY_WALLET_ADDRESS,
      abiFunctionSignature: "deposit(address,uint256)",
      abiParameters: [
        USDC_ADDRESS,
        parseBalance(DEPOSIT_AMOUNT_USDC).toString(),
      ],
      fee: { type: "level", config: { feeLevel: "MEDIUM" } },
    });

    const depositTxId = depositTx.data?.id;
    if (!depositTxId) throw new Error("Failed to create deposit transaction");

    await waitForTxCompletion(client, depositTxId, "Gateway deposit");
  }

  console.log(
    "Transaction complete. Once finality is reached, Gateway credits your unified USDC balance.",
  );
}

main().catch((error) => {
  console.error("\nError:", error?.response?.data ?? error);
  process.exit(1);
});
```

### 3.7. Run the script to create a crosschain balance

Run the `deposit` script to make the deposits. You can select which chain to
deposit from using command-line arguments.

```shell  theme={null}
# Deposit to all chains
npm run deposit

# Deposit to a single chain
npm run deposit -- base

# Deposit to multiple chains
npm run deposit -- base avalanche
```

Wait for the
[required number of block confirmations](https://developers.circle.com/gateway/references/supported-blockchains#required-block-confirmations).
Once the deposit transactions are final, the total balance is the sum of all the
USDC from deposit transactions across all supported chains that have reached
finality. Note that for certain chains, finality may take up to 20 minutes to be
reached.

### 3.8. Check the balances on the Gateway Wallet

Create a new file called `balances.ts`, and add the following code. This script
retrieves the USDC balances available from your Gateway Wallet on each supported
chain. You can run it to check whether finality has been reached for recent
transactions.

```shell  theme={null}
touch balances.ts
```

Replace the placeholder `<WALLET_ID>` in the `main()` function with any of the
wallet IDs from the created wallets. The code derives the address from the
wallet ID provided.

```ts  theme={null}
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

const GATEWAY_API = "https://gateway-api-testnet.circle.com/v1";

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const CHAINS = {
  ethereum: { domain: 0, name: "Ethereum Sepolia" },
  avalanche: { domain: 1, name: "Avalanche Fuji" },
  base: { domain: 6, name: "Base Sepolia" },
  arc: { domain: 26, name: "Arc Testnet" },
};
const chainList = Object.values(CHAINS);
const domainNames = Object.fromEntries(
  chainList.map((chain) => [chain.domain, chain.name]),
);

const toBigInt = (value: string | number | null | undefined): bigint => {
  const balanceString = String(value ?? "0");
  if (balanceString.includes(".")) {
    const [whole, decimal = ""] = balanceString.split(".");
    const decimal6 = (decimal + "000000").slice(0, 6);
    return BigInt((whole || "0") + decimal6);
  }
  return BigInt(balanceString || "0");
};

async function showUnifiedAvailableBalance(client: any, walletId: string) {
  const { data } = await client.getWallet({ id: walletId });
  const depositor = data?.wallet?.address;
  if (!depositor) throw new Error("Could not resolve wallet address");
  console.log(`Depositor address: ${depositor}`);

  // Query Gateway for the available balance recorded by the system
  const response = await fetch(`${GATEWAY_API}/balances`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      token: "USDC",
      sources: chainList.map(({ domain }) => ({ domain, depositor })),
    }),
  });
  const { balances = [] } = await response.json();

  let totalBalances = 0n;
  for (const balance of balances) {
    const amount = toBigInt(balance?.balance);
    const chain =
      domainNames[balance!.domain as number] ??
      `Domain ${balance!.domain as number}`;
    console.log(
      `  - ${chain}: ${amount / 1_000_000n}.${(amount % 1_000_000n)
        .toString()
        .padStart(6, "0")} USDC`,
    );
    totalBalances += amount;
  }
  const whole = totalBalances / 1_000_000n;
  const decimal = totalBalances % 1_000_000n;
  const totalUsdc = `${whole}.${decimal.toString().padStart(6, "0")}`;
  console.log(`Unified USDC available: ${totalUsdc} USDC`);
}

async function main() {
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });
  const walletId = "<WALLET_ID>";
  await showUnifiedAvailableBalance(client, walletId);
}

main().catch((error) => {
  console.error("\n Error:", error?.response?.data ?? error);
  process.exit(1);
});
```

Run the script to check the unified balance.

```shell  theme={null}
npm run balances
```

## Step 4: Transfer USDC from the crosschain balance to Arc

In this step, you can review the transfer script, covering configuration,
approval, and minting USDC on Arc from your crosschain balance. You can skip to
the [full transfer script](#4-8-full-transfer-script) if you prefer.

### 4.1. Create the script file

```shell  theme={null}
touch transfer.ts
```

### 4.2. Define chain configuration

```ts  theme={null}
type WalletChain = "ETH-SEPOLIA" | "BASE-SEPOLIA" | "AVAX-FUJI" | "ARC-TESTNET";

type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
  domain: number;
  walletChain: WalletChain;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
    domain: 0,
    walletChain: "ETH-SEPOLIA",
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
    domain: 6,
    walletChain: "BASE-SEPOLIA",
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
    domain: 1,
    walletChain: "AVAX-FUJI",
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
    domain: 26,
    walletChain: "ARC-TESTNET",
  },
};
```

### 4.3. Define constants and EIP-712 typed data types

These constants define the parameters for transferring funds from your Gateway
balance to a wallet on the destination chain.

* Replace the `<WALLET_ADDRESS>` placeholder with the unified wallet address of
  your created dev-controlled wallets. You can run the `balances.ts` script to
  check the balance.
* The `DESTINATION_CHAIN` is currently set to `BASE-SEPOLIA` but you can change
  it to a chain of your choice. Note that
  [gas fees](https://developers.circle.com/gateway/references/fees#table-of-fees)
  differ between chains.
* Replace the `<RECIPIENT_ADDRESS>` placeholder with a wallet address on the
  destination chain.
* You can set the amount of USDC to be transfered from each chain within the
  unified balance, which is currently set to 1 USDC.

```ts  theme={null}
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";
const GATEWAY_MINTER_ADDRESS = "0x0022222ABE238Cc2C7Bb1f21003F0a260052475B";
const MAX_UINT256_DEC = ((1n << 256n) - 1n).toString();

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSITOR_ADDRESS = "<WALLET_ADDRESS>";
const DESTINATION_CHAIN: WalletChain = "<DESTINATION_CHAIN>"; // "ETH-SEPOLIA" | "BASE-SEPOLIA" | "AVAX-FUJI" | "ARC-TESTNET"
const RECIPIENT_ADDRESS = "<RECIPIENT_ADDRESS>";
const TRANSFER_AMOUNT_USDC = 1;

/* Burn intent and EIP-712 definitions */
type BurnIntentSpec = {
  version: number;
  sourceDomain: number;
  destinationDomain: number;
  sourceContract: string;
  destinationContract: string;
  sourceToken: string;
  destinationToken: string;
  sourceDepositor: string;
  destinationRecipient: string;
  sourceSigner: string;
  destinationCaller: string;
  value: bigint;
  salt: string;
  hookData: string;
};

type BurnIntentType = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: BurnIntentSpec;
};

type EIP712DomainType = {
  name: string;
  version: string;
};

type TypedDataMessage = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: {
    version: number;
    sourceDomain: number;
    destinationDomain: number;
    sourceContract: string;
    destinationContract: string;
    sourceToken: string;
    destinationToken: string;
    sourceDepositor: string;
    destinationRecipient: string;
    sourceSigner: string;
    destinationCaller: string;
    value: bigint;
    salt: string;
    hookData: string;
  };
};

type SignedBurnIntentRequest = {
  burnIntent: TypedDataMessage;
  signature: string | undefined;
};

const EIP712Domain = [
  { name: "name", type: "string" },
  { name: "version", type: "string" },
];

const TransferSpec = [
  { name: "version", type: "uint32" },
  { name: "sourceDomain", type: "uint32" },
  { name: "destinationDomain", type: "uint32" },
  { name: "sourceContract", type: "bytes32" },
  { name: "destinationContract", type: "bytes32" },
  { name: "sourceToken", type: "bytes32" },
  { name: "destinationToken", type: "bytes32" },
  { name: "sourceDepositor", type: "bytes32" },
  { name: "destinationRecipient", type: "bytes32" },
  { name: "sourceSigner", type: "bytes32" },
  { name: "destinationCaller", type: "bytes32" },
  { name: "value", type: "uint256" },
  { name: "salt", type: "bytes32" },
  { name: "hookData", type: "bytes" },
];

const BurnIntent = [
  { name: "maxBlockHeight", type: "uint256" },
  { name: "maxFee", type: "uint256" },
  { name: "spec", type: "TransferSpec" },
];
```

### 4.4. Add helper functions

```ts  theme={null}
// Construct burn intent for a given source chain
function makeBurnIntent(sourceChain: Chain) {
  const src = CHAIN_CONFIG[sourceChain];
  const dst = getConfigByWalletChain(DESTINATION_CHAIN);
  const value = parseBalance(String(TRANSFER_AMOUNT_USDC));

  return {
    maxBlockHeight: MAX_UINT256_DEC,
    maxFee: 2_010000n,
    spec: {
      version: 1,
      sourceDomain: src.domain,
      destinationDomain: dst.domain,
      sourceContract: GATEWAY_WALLET_ADDRESS,
      destinationContract: GATEWAY_MINTER_ADDRESS,
      sourceToken: src.usdc,
      destinationToken: dst.usdc,
      sourceDepositor: DEPOSITOR_ADDRESS,
      destinationRecipient: RECIPIENT_ADDRESS,
      sourceSigner: DEPOSITOR_ADDRESS,
      destinationCaller: addressToBytes32(
        "0x0000000000000000000000000000000000000000",
      ),
      value: value,
      salt: "0x" + randomBytes(32).toString("hex"),
      hookData: "0x",
    },
  };
}

// Format burn intent as EIP-712 typed data for signing
function burnIntentTypedData(
  burnIntent: BurnIntentType,
  domain: EIP712DomainType,
) {
  return {
    types: { EIP712Domain, TransferSpec, BurnIntent },
    domain,
    primaryType: "BurnIntent",
    message: {
      ...burnIntent,
      spec: {
        ...burnIntent.spec,
        sourceContract: addressToBytes32(burnIntent.spec.sourceContract),
        destinationContract: addressToBytes32(
          burnIntent.spec.destinationContract,
        ),
        sourceToken: addressToBytes32(burnIntent.spec.sourceToken),
        destinationToken: addressToBytes32(burnIntent.spec.destinationToken),
        sourceDepositor: addressToBytes32(burnIntent.spec.sourceDepositor),
        destinationRecipient: addressToBytes32(
          burnIntent.spec.destinationRecipient,
        ),
        sourceSigner: addressToBytes32(burnIntent.spec.sourceSigner),
        destinationCaller: addressToBytes32(
          burnIntent.spec.destinationCaller ??
            addressToBytes32("0x0000000000000000000000000000000000000000"),
        ),
      },
    },
  };
}

// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Look up chain configuration by wallet chain
function getConfigByWalletChain(walletChain: WalletChain) {
  const entry = Object.values(CHAIN_CONFIG).find(
    (item) => item.walletChain === walletChain,
  );
  if (!entry) {
    throw new Error(`No config found for destination chain ${walletChain}`);
  }
  return entry;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run transfer -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run transfer -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Pad address to 32 bytes
function addressToBytes32(address: string) {
  return ("0x" +
    address
      .toLowerCase()
      .replace(/^0x/, "")
      .padStart(64, "0")) as `0x${string}`;
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}

// Format base units to decimal: 10500000n → "10.5"
function formatUnits(value: bigint, decimals: number) {
  let display = value.toString();

  const negative = display.startsWith("-");
  if (negative) display = display.slice(1);

  display = display.padStart(decimals, "0");

  const integer = display.slice(0, display.length - decimals);
  let fraction = display.slice(display.length - decimals);

  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// Serialize typed data (convert bigints to strings)
function stringifyTypedData<T>(obj: T) {
  return JSON.stringify(obj, (_key, value) =>
    typeof value === "bigint" ? value.toString() : value,
  );
}
```

### 4.5. Construct and sign the burn intents

First, within the main logic, you need to build the requests and sign them
before they can be submitted to the Gateway API.

```ts  theme={null}
const requests: any[] = [];
const burnIntentsForTotal: any[] = [];

for (const chain of selectedChains) {
  const config = CHAIN_CONFIG[chain];

  const burnIntent = makeBurnIntent(chain);
  const typedData = burnIntentTypedData(burnIntent, domain);

  const sigResp = await client.signTypedData({
    walletId: config.walletId,
    data: stringifyTypedData(typedData),
  });

  requests.push({
    burnIntent: typedData.message,
    signature: sigResp.data?.signature,
  });

  burnIntentsForTotal.push(burnIntent);
}
```

### 4.6. Submit the burn intents to the API

Then, you use the signed burn intents to request an attestation from the Gateway
API.

```ts  theme={null}
const response = await fetch(
  "https://gateway-api-testnet.circle.com/v1/transfer",
  {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(requests, (_key, value) =>
      typeof value === "bigint" ? value.toString() : value,
    ),
  },
);

const json = await response.json();
const attestation = json?.attestation;
const operatorSig = json?.signature;

if (!attestation || !operatorSig) {
  console.error("Gateway /transfer error:", json);
  process.exit(1);
}
```

### 4.7. Mint USDC on destination chain

Finally, you need to pass the attestation to mint USDC to the destination chain
by calling `gatewayMint()` on the Gateway Minter contract.

```ts  theme={null}
const tx = await client.createContractExecutionTransaction({
  walletAddress: DEPOSITOR_ADDRESS,
  blockchain: DESTINATION_CHAIN,
  contractAddress: GATEWAY_MINTER_ADDRESS,
  abiFunctionSignature: "gatewayMint(bytes,bytes)",
  abiParameters: [attestation, operatorSig],
  fee: { type: "level", config: { feeLevel: "MEDIUM" } },
});

console.log("Mint tx submitted:", tx.data?.id);

const txId = tx.data?.id;
if (!txId) throw new Error("Failed to submit mint transaction");
await waitForTxCompletion(client, txId, "USDC mint");

const totalMintBaseUnits = burnIntentsForTotal.reduce(
  (sum, i) => sum + (i.spec.value ?? 0n),
  0n,
);
console.log(`Minted ${formatUnits(totalMintBaseUnits, 6)} USDC`);
```

### 4.8. Full transfer script

Now that you've covered the setup and core steps, this full script puts
everything together and transfers out 1 USDC from each specified Gateway
balances to the destination address. It includes comments that describe what
each function does as well for reference.

```ts  theme={null}
import { randomBytes } from "node:crypto";
import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

/* Chain configuration */
type WalletChain = "ETH-SEPOLIA" | "BASE-SEPOLIA" | "AVAX-FUJI" | "ARC-TESTNET";

type Chain = "ethereum" | "base" | "avalanche" | "arc";

type ChainConfig = {
  chainName: string;
  usdc: string;
  walletId: string;
  domain: number;
  walletChain: WalletChain;
};

const CHAIN_CONFIG: Record<Chain, ChainConfig> = {
  ethereum: {
    chainName: "Ethereum Sepolia",
    usdc: "0x1c7D4B196Cb0C7B01d743Fbc6116a902379C7238",
    walletId: getRequiredWalletId("ETH_SEPOLIA_WALLET_ID"),
    domain: 0,
    walletChain: "ETH-SEPOLIA",
  },
  base: {
    chainName: "Base Sepolia",
    usdc: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
    walletId: getRequiredWalletId("BASE_SEPOLIA_WALLET_ID"),
    domain: 6,
    walletChain: "BASE-SEPOLIA",
  },
  avalanche: {
    chainName: "Avalanche Fuji",
    usdc: "0x5425890298aed601595a70AB815c96711a31Bc65",
    walletId: getRequiredWalletId("AVAX_FUJI_WALLET_ID"),
    domain: 1,
    walletChain: "AVAX-FUJI",
  },
  arc: {
    chainName: "Arc Testnet",
    usdc: "0x3600000000000000000000000000000000000000",
    walletId: getRequiredWalletId("ARC_TESTNET_WALLET_ID"),
    domain: 26,
    walletChain: "ARC-TESTNET",
  },
};

/* Constants */
const GATEWAY_WALLET_ADDRESS = "0x0077777d7EBA4688BDeF3E311b846F25870A19B9";
const GATEWAY_MINTER_ADDRESS = "0x0022222ABE238Cc2C7Bb1f21003F0a260052475B";
const MAX_UINT256_DEC = ((1n << 256n) - 1n).toString();

const API_KEY = process.env.CIRCLE_API_KEY;
const ENTITY_SECRET = process.env.CIRCLE_ENTITY_SECRET;

if (!API_KEY || !ENTITY_SECRET) {
  console.error("Missing CIRCLE_API_KEY or CIRCLE_ENTITY_SECRET in .env");
  process.exit(1);
}

const DEPOSITOR_ADDRESS = "0xd02419296ef08a575e6dea178950e9c9c25126b8";
const DESTINATION_CHAIN: WalletChain = "AVAX-FUJI";
const RECIPIENT_ADDRESS = "0x8b4ac46d9267e25f4d40092b33aedc150ebe5cdf";
const TRANSFER_AMOUNT_USDC = 1;

/* Burn intent and EIP-712 definitions */
type BurnIntentSpec = {
  version: number;
  sourceDomain: number;
  destinationDomain: number;
  sourceContract: string;
  destinationContract: string;
  sourceToken: string;
  destinationToken: string;
  sourceDepositor: string;
  destinationRecipient: string;
  sourceSigner: string;
  destinationCaller: string;
  value: bigint;
  salt: string;
  hookData: string;
};

type BurnIntentType = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: BurnIntentSpec;
};

type EIP712DomainType = {
  name: string;
  version: string;
};

type TypedDataMessage = {
  maxBlockHeight: string;
  maxFee: bigint;
  spec: {
    version: number;
    sourceDomain: number;
    destinationDomain: number;
    sourceContract: string;
    destinationContract: string;
    sourceToken: string;
    destinationToken: string;
    sourceDepositor: string;
    destinationRecipient: string;
    sourceSigner: string;
    destinationCaller: string;
    value: bigint;
    salt: string;
    hookData: string;
  };
};

type SignedBurnIntentRequest = {
  burnIntent: TypedDataMessage;
  signature: string | undefined;
};

const EIP712Domain = [
  { name: "name", type: "string" },
  { name: "version", type: "string" },
];

const TransferSpec = [
  { name: "version", type: "uint32" },
  { name: "sourceDomain", type: "uint32" },
  { name: "destinationDomain", type: "uint32" },
  { name: "sourceContract", type: "bytes32" },
  { name: "destinationContract", type: "bytes32" },
  { name: "sourceToken", type: "bytes32" },
  { name: "destinationToken", type: "bytes32" },
  { name: "sourceDepositor", type: "bytes32" },
  { name: "destinationRecipient", type: "bytes32" },
  { name: "sourceSigner", type: "bytes32" },
  { name: "destinationCaller", type: "bytes32" },
  { name: "value", type: "uint256" },
  { name: "salt", type: "bytes32" },
  { name: "hookData", type: "bytes" },
];

const BurnIntent = [
  { name: "maxBlockHeight", type: "uint256" },
  { name: "maxFee", type: "uint256" },
  { name: "spec", type: "TransferSpec" },
];

/* Helpers */
// Construct burn intent for a given source chain
function makeBurnIntent(sourceChain: Chain) {
  const src = CHAIN_CONFIG[sourceChain];
  const dst = getConfigByWalletChain(DESTINATION_CHAIN);
  const value = parseBalance(String(TRANSFER_AMOUNT_USDC));

  return {
    maxBlockHeight: MAX_UINT256_DEC,
    maxFee: 2_010000n,
    spec: {
      version: 1,
      sourceDomain: src.domain,
      destinationDomain: dst.domain,
      sourceContract: GATEWAY_WALLET_ADDRESS,
      destinationContract: GATEWAY_MINTER_ADDRESS,
      sourceToken: src.usdc,
      destinationToken: dst.usdc,
      sourceDepositor: DEPOSITOR_ADDRESS,
      destinationRecipient: RECIPIENT_ADDRESS,
      sourceSigner: DEPOSITOR_ADDRESS,
      destinationCaller: addressToBytes32(
        "0x0000000000000000000000000000000000000000",
      ),
      value: value,
      salt: "0x" + randomBytes(32).toString("hex"),
      hookData: "0x",
    },
  };
}

// Format burn intent as EIP-712 typed data for signing
function burnIntentTypedData(
  burnIntent: BurnIntentType,
  domain: EIP712DomainType,
) {
  return {
    types: { EIP712Domain, TransferSpec, BurnIntent },
    domain,
    primaryType: "BurnIntent",
    message: {
      ...burnIntent,
      spec: {
        ...burnIntent.spec,
        sourceContract: addressToBytes32(burnIntent.spec.sourceContract),
        destinationContract: addressToBytes32(
          burnIntent.spec.destinationContract,
        ),
        sourceToken: addressToBytes32(burnIntent.spec.sourceToken),
        destinationToken: addressToBytes32(burnIntent.spec.destinationToken),
        sourceDepositor: addressToBytes32(burnIntent.spec.sourceDepositor),
        destinationRecipient: addressToBytes32(
          burnIntent.spec.destinationRecipient,
        ),
        sourceSigner: addressToBytes32(burnIntent.spec.sourceSigner),
        destinationCaller: addressToBytes32(
          burnIntent.spec.destinationCaller ??
            addressToBytes32("0x0000000000000000000000000000000000000000"),
        ),
      },
    },
  };
}

// Get required wallet ID from env
function getRequiredWalletId(envKey: string) {
  const value = process.env[envKey];
  if (!value) {
    console.error(`Missing ${envKey} in .env`);
    process.exit(1);
  }
  return value;
}

// Look up chain configuration by wallet chain
function getConfigByWalletChain(walletChain: WalletChain) {
  const entry = Object.values(CHAIN_CONFIG).find(
    (item) => item.walletChain === walletChain,
  );
  if (!entry) {
    throw new Error(`No config found for destination chain ${walletChain}`);
  }
  return entry;
}

// Parse chains from CLI arguments
function parseSelectedChains() {
  const args = process.argv.slice(2).map((chain) => chain.toLowerCase());
  if (args.length === 0) return Object.keys(CHAIN_CONFIG) as Chain[];

  const selected: Chain[] = [];
  for (const arg of args) {
    if (!(arg in CHAIN_CONFIG)) {
      console.error(
        `Unsupported chain: ${arg}\n` +
          `Usage: npm run transfer -- [${Object.keys(CHAIN_CONFIG).join("] [")}]\n` +
          `Example: npm run transfer -- base avalanche`,
      );
      process.exit(1);
    }
    selected.push(arg as Chain);
  }
  return dedupe(selected);
}

// Dedupe chains from CLI arguments
function dedupe<T>(array: T[]) {
  const chains = new Set<T>();
  return array.filter((chain) =>
    chains.has(chain) ? false : (chains.add(chain), true),
  );
}

// Poll until transaction reaches terminal state
async function waitForTxCompletion(
  client: ReturnType<typeof initiateDeveloperControlledWalletsClient>,
  txId: string,
  label: string,
) {
  const terminalStates = new Set([
    "COMPLETE",
    "CONFIRMED",
    "FAILED",
    "DENIED",
    "CANCELLED",
  ]);

  process.stdout.write(`Waiting for ${label} (txId=${txId})\n`);

  while (true) {
    const { data } = await client.getTransaction({ id: txId });
    const state = data?.transaction?.state;

    process.stdout.write(".");

    if (state && terminalStates.has(state)) {
      process.stdout.write("\n");
      console.log(`${label} final state: ${state}`);

      if (state !== "COMPLETE" && state !== "CONFIRMED") {
        throw new Error(
          `${label} did not complete successfully (state=${state})`,
        );
      }
      return data.transaction;
    }
    await new Promise((resolve) => setTimeout(resolve, 3000));
  }
}

// Pad address to 32 bytes
function addressToBytes32(address: string) {
  return ("0x" +
    address
      .toLowerCase()
      .replace(/^0x/, "")
      .padStart(64, "0")) as `0x${string}`;
}

// Parse decimal to base units: "10.5" → 10500000n
function parseBalance(usdcStr: string) {
  const [whole, decimal = ""] = String(usdcStr).split(".");
  const decimal6 = (decimal + "000000").slice(0, 6);
  return BigInt(whole + decimal6);
}

// Format base units to decimal: 10500000n → "10.5"
function formatUnits(value: bigint, decimals: number) {
  let display = value.toString();

  const negative = display.startsWith("-");
  if (negative) display = display.slice(1);

  display = display.padStart(decimals, "0");

  const integer = display.slice(0, display.length - decimals);
  let fraction = display.slice(display.length - decimals);

  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}

// Serialize typed data (convert bigints to strings)
function stringifyTypedData<T>(obj: T) {
  return JSON.stringify(obj, (_key, value) =>
    typeof value === "bigint" ? value.toString() : value,
  );
}

/* Main logic */
async function main() {
  // Allows for chain selection via CLI arguments
  const selectedChains = parseSelectedChains();
  console.log(
    `Transfering balances from: ${selectedChains.map((c) => CHAIN_CONFIG[c].chainName).join(", ")}`,
  );

  // Initiate wallets client
  const client = initiateDeveloperControlledWalletsClient({
    apiKey: API_KEY!,
    entitySecret: ENTITY_SECRET!,
  });

  const domain = { name: "GatewayWallet", version: "1" };

  // Build requests only for selected chains
  const requests: SignedBurnIntentRequest[] = [];
  const burnIntentsForTotal: BurnIntentType[] = [];

  for (const chain of selectedChains) {
    const config = CHAIN_CONFIG[chain];

    const burnIntent = makeBurnIntent(chain);
    const typedData = burnIntentTypedData(burnIntent, domain);

    const sigResp = await client.signTypedData({
      walletId: config.walletId,
      data: stringifyTypedData(typedData),
    });

    requests.push({
      burnIntent: typedData.message,
      signature: sigResp.data?.signature,
    });

    burnIntentsForTotal.push(burnIntent);
  }

  // Submit burn intents to Gateway API to obtain an attestation
  const response = await fetch(
    "https://gateway-api-testnet.circle.com/v1/transfer",
    {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requests, (_key, value) =>
        typeof value === "bigint" ? value.toString() : value,
      ),
    },
  );

  const json = await response.json();
  const attestation = json?.attestation;
  const operatorSig = json?.signature;

  if (!attestation || !operatorSig) {
    console.error("Gateway /transfer error:", json);
    process.exit(1);
  }

  // Mint on the destination chain
  const tx = await client.createContractExecutionTransaction({
    walletAddress: DEPOSITOR_ADDRESS,
    blockchain: DESTINATION_CHAIN,
    contractAddress: GATEWAY_MINTER_ADDRESS,
    abiFunctionSignature: "gatewayMint(bytes,bytes)",
    abiParameters: [attestation, operatorSig],
    fee: { type: "level", config: { feeLevel: "MEDIUM" } },
  });

  console.log("Mint tx submitted:", tx.data?.id);

  const txId = tx.data?.id;
  if (!txId) throw new Error("Failed to submit mint transaction");
  await waitForTxCompletion(client, txId, "USDC mint");

  const totalMintBaseUnits = burnIntentsForTotal.reduce(
    (sum, i) => sum + (i.spec.value ?? 0n),
    0n,
  );
  console.log(`Minted ${formatUnits(totalMintBaseUnits, 6)} USDC`);
}

main().catch((error) => {
  console.error("\nError:", error?.response?.data ?? error);
  process.exit(1);
});
```

### 4.9. Run the script to transfer USDC to destination chain

Run the `transfer` script to transfer 1 USDC from each selected Gateway balance
to the destination chain.

<Note>
  [Gateway gas fees](https://developers.circle.com/gateway/references/fees) are
  charged per burn intent. To reduce overall gas costs, consider keeping most
  Gateway funds on low-cost chains, where Circle's base fee for burns is
  cheaper.
</Note>

```shell  theme={null}
# Transfer from all chains
npm run transfer

# Transfer from a single chain
npm run transfer -- base

# Transfer from multiple chains
npm run transfer -- ethereum avalanche
```

## Summary

After completing this tutorial, you've successfully:

* Created dev-controlled wallets
* Funded your wallet with testnet USDC
* Created a unified USDC balance
* Transferred USDC out from your unified USDC balance

> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Deploy contracts

> Deploy pre-audited smart contract templates on Arc with Circle Contracts.

This tutorial guides you through deploying smart contracts on Arc Testnet with
[Circle Contracts](https://developers.circle.com/contracts/scp-templates-overview).
You'll create a
[Circle Dev-Controlled Wallet](https://developers.circle.com/wallets/dev-controlled),
fund it with the [Circle Faucet](https://faucet.circle.com/), then deploy
pre-audited contract templates (ERC-20, ERC-721, ERC-1155, Airdrop).

These pre-audited templates represent building blocks: ERC-20 for money and
liquidity, ERC-721 for identity and unique rights, ERC-1155 for scalable
financial instruments, and Airdrops for distributing incentives. To learn more
about available templates, visit the
[Templates Overview](https://developers.circle.com/contracts/scp-templates-overview)
to review all templates and their options.

## Prerequisites

To complete this tutorial, you need:

1. [Node.js v22+](https://nodejs.org/) installed
2. **Circle Developer Account** - [Sign up](https://console.circle.com/) on the
   Developer Console
3. **API Key** - Create in the Console: **Keys → Create a key → API key →
   Standard Key**
4. **Entity Secret** - Required to initialize the Circle Dev-Controlled Wallets
   SDK. Learn how to
   [register your Entity Secret](https://developers.circle.com/wallets/dev-controlled/register-entity-secret)

## Set up your environment

Before deploying any template, you need a working project and a funded
dev-controlled wallet on Arc Testnet. Complete the steps in this section once.
Then reuse the same wallet and credentials across all template deployments
below.

### Step 1: Set up your project

Set up your local environment and install the required dependencies.

#### 1.1. Create a new project

Create a new directory. Navigate to it and start a new project with default
settings.

<CodeGroup>
  ```shell Node.js theme={null}
  mkdir hello-arc
  cd hello-arc
  npm init -y
  npm pkg set type=module

  # Add run scripts for wallet creation and contract deployment
  npm pkg set scripts.create-wallet="tsx --env-file=.env create-wallet.ts"
  npm pkg set scripts.check-balance="tsx --env-file=.env check-balance.ts"
  npm pkg set scripts.deploy-erc20="tsx --env-file=.env deploy-erc20.ts"
  npm pkg set scripts.deploy-erc721="tsx --env-file=.env deploy-erc721.ts"
  npm pkg set scripts.deploy-erc1155="tsx --env-file=.env deploy-erc1155.ts"
  npm pkg set scripts.deploy-airdrop="tsx --env-file=.env deploy-airdrop.ts"
  npm pkg set scripts.check-transaction="tsx --env-file=.env check-transaction.ts"
  npm pkg set scripts.get-contract="tsx --env-file=.env get-contract.ts"
  ```

  ```shell Python theme={null}
  mkdir hello-arc
  cd hello-arc
  python3 -m venv .venv
  source .venv/bin/activate
  ```
</CodeGroup>

#### 1.2. Install dependencies

In the project directory, install the
[Circle Dev-Controlled Wallets SDK](https://developers.circle.com/wallets/dev-controlled)
and the [Circle Contracts SDK](https://developers.circle.com/sdks).
Dev-Controlled Wallets are Circle-managed wallets that your app controls via
APIs. You can deploy contracts and submit transactions without managing private
keys directly. You can also call the
[Circle Wallets API](https://developers.circle.com/api-reference/wallets/) and
[Circle Contracts API](https://developers.circle.com/api-reference/contracts/)
directly if you can't use the SDKs in your project.

<CodeGroup>
  ```shell Node.js theme={null}
  npm install @circle-fin/developer-controlled-wallets @circle-fin/smart-contract-platform
  npm install --save-dev tsx typescript @types/node
  ```

  ```shell Python theme={null}
  pip install circle-smart-contract-platform circle-developer-controlled-wallets
  ```
</CodeGroup>

#### 1.3. Initialize and configure the project

This command creates a `tsconfig.json` file:

<CodeGroup>
  ```shell Node.js theme={null}
  # Initialize a TypeScript project
  npx tsc --init
  ```

  ```shell Python theme={null}
  # Python doesn't require TypeScript configuration
  ```
</CodeGroup>

Then, edit the `tsconfig.json` file:

<CodeGroup>
  ```shell Node.js theme={null}
  # Replace the contents of the generated file
  cat <<'EOF' > tsconfig.json
  {
    "compilerOptions": {
      "target": "ESNext",
      "module": "ESNext",
      "moduleResolution": "bundler",
      "strict": true,
      "types": ["node"]
    }
  }
  EOF
  ```

  ```shell Python theme={null}
  # Python doesn't require TypeScript configuration
  ```
</CodeGroup>

#### 1.4 Configure environment variables

Create a `.env` file in the project directory with your Circle credentials.
Replace these placeholders with your own credentials:

* `CIRCLE_API_KEY`: your API key should be either environment-prefixed (for
  example, `TEST_API_KEY:abc123:def456` or `LIVE_API_KEY:xyz:uvw`) or
  base64-encoded strings.
* `CIRCLE_ENTITY_SECRET`: your entity secret should be 64 lowercase alphanumeric
  characters.
* `CIRCLE_WEB3_API_KEY`: (Python only) set to the same value as `CIRCLE_API_KEY`
  for Python SDK compatibility.

```shell  theme={null}
echo "CIRCLE_API_KEY={YOUR_API_KEY}
CIRCLE_ENTITY_SECRET={YOUR_ENTITY_SECRET}
CIRCLE_WEB3_API_KEY={YOUR_API_KEY}
WALLET_ID={WALLET_ID_FROM_STEP_2}
WALLET_ADDRESS={WALLET_ADDRESS_FROM_STEP_2}
TRANSACTION_ID={TRANSACTION_ID_FROM_DEPLOYMENT}
CONTRACT_ID={CONTRACT_ID_FROM_DEPLOYMENT}" > .env
```

<Note>
  You'll update `WALLET_ID` and `WALLET_ADDRESS` after creating your wallet in
  Step 2, then update `TRANSACTION_ID` and `CONTRACT_ID` after running the
  deployment script in Step 4.
</Note>

<Warning>
  Important: These are sensitive credentials. Do not commit them to version
  control or share them publicly.
</Warning>

### Step 2: Set up your wallet

Create a dev-controlled wallet and fund it with testnet USDC. This covers gas
fees for deploying your smart contract.

#### 2.1. Create a wallet

Import the Wallets SDK and start the client with your API key and Entity Secret.
Dev-controlled wallets are created in a
[wallet set](https://developers.circle.com/wallets/dev-controlled/create-your-first-wallet#1-create-a-wallet-set).
The wallet set is the source from which wallet keys are derived.

<CodeGroup>
  ```ts create-wallet.ts theme={null}
  import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

  const client = initiateDeveloperControlledWalletsClient({
    apiKey: process.env.CIRCLE_API_KEY,
    entitySecret: process.env.CIRCLE_ENTITY_SECRET,
  });

  // Create a wallet set
  const walletSetResponse = await client.createWalletSet({
    name: "Wallet Set 1",
  });

  // Create a wallet on Arc Testnet
  const walletsResponse = await client.createWallets({
    blockchains: ["ARC-TESTNET"],
    count: 1,
    walletSetId: walletSetResponse.data?.walletSet?.id ?? "",
    accountType: "SCA",
  });

  console.log(JSON.stringify(walletsResponse.data, null, 2));
  ```

  ```python create_wallet.py theme={null}
  from circle.web3 import utils, developer_controlled_wallets
  import os
  import json

  client = utils.init_developer_controlled_wallets_client(
      api_key=os.getenv("CIRCLE_API_KEY"),
      entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
  )

  wallet_sets_api = developer_controlled_wallets.WalletSetsApi(client)
  wallets_api = developer_controlled_wallets.WalletsApi(client)

  # Create a wallet set
  wallet_set = wallet_sets_api.create_wallet_set(
      developer_controlled_wallets.CreateWalletSetRequest.from_dict({
          "name": "Wallet Set 1"
      })
  )

  # Create a wallet on Arc Testnet
  wallet = wallets_api.create_wallet(
      developer_controlled_wallets.CreateWalletRequest.from_dict({
          "blockchains": ["ARC-TESTNET"],
          "count": 1,
          "walletSetId": wallet_set.data.wallet_set.actual_instance.id,
          "accountType": "SCA"
      })
  )

  print(json.dumps(wallet.data.to_dict(), indent=2))
  ```
</CodeGroup>

**Run the script:**

<CodeGroup>
  ```shell Node.js theme={null}
  npm run create-wallet
  ```

  ```shell Python theme={null}
  python create_wallet.py
  ```
</CodeGroup>

**Response:**

<Note>
  If you're calling the API directly, you'll need two requests. One to [create
  the wallet
  set](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet-set).
  One to [create the
  wallet](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/create-wallet).

  Be sure to replace the
  [Entity Secret ciphertext](https://developers.circle.com/wallets/dev-controlled/entity-secret-management#what-is-an-entity-secret-ciphertext)
  and the idempotency key in your request. If you're using the SDKs, this is
  handled for you.
</Note>

You should now have a newly created dev-controlled wallet. The API response will
look similar to the following:

```json  theme={null}
{
  "wallets": [
    {
      "id": "45692c3e-2ffa-5c5b-a99c-61366939114c",
      "state": "LIVE",
      "walletSetId": "ee58db40-22b4-55cb-9ce6-3444cb6efd2f",
      "custodyType": "DEVELOPER",
      "address": "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
      "blockchain": "ARC-TESTNET",
      "accountType": "SCA",
      "updateDate": "2026-01-20T09:39:16Z",
      "createDate": "2026-01-20T09:39:16Z",
      "scaCore": "circle_6900_singleowner_v3"
    }
  ]
}
```

#### 2.2. Fund the wallet with testnet USDC

Use the [Circle Faucet](https://faucet.circle.com/) to get testnet USDC. You'll
need a funded balance to deploy contracts, mint tokens, and pay gas fees.

To fund your wallet:

1. Copy your wallet address from the response in step 2.1
2. Visit [faucet.circle.com](https://faucet.circle.com/)
3. Select **Arc Testnet** as the network
4. Paste your wallet address
5. Request testnet USDC

#### 2.3. Check the wallet's balance

You can check your wallet's balance from the
[Developer Console](https://console.circle.com/wallets/dev/wallets). You can
also check it by making a request to
[GET /wallets/\{id}/balances](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/list-wallet-balance).

After creating your wallet, copy the wallet `id` from the response and update
your `.env` file with `WALLET_ID={your-wallet-id}`. Then run the check-balance
script to verify your wallet was funded.

<CodeGroup>
  ```ts check-balance.ts theme={null}
  import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

  const client = initiateDeveloperControlledWalletsClient({
    apiKey: process.env.CIRCLE_API_KEY,
    entitySecret: process.env.CIRCLE_ENTITY_SECRET,
  });

  const response = await client.getWalletTokenBalance({
    id: process.env.WALLET_ID!,
  });

  console.log(JSON.stringify(response.data, null, 2));
  ```

  ```python check_balance.py theme={null}
  from circle.web3 import utils, developer_controlled_wallets
  from pathlib import Path
  from dotenv import load_dotenv
  import os
  import json

  # Load environment variables
  env_path = Path(__file__).resolve().parent / ".env"
  load_dotenv(env_path)

  client = utils.init_developer_controlled_wallets_client(
      api_key=os.getenv("CIRCLE_API_KEY"),
      entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
  )

  wallets_api = developer_controlled_wallets.WalletsApi(client)
  response = wallets_api.list_wallet_balance(id=os.getenv("WALLET_ID"))

  print(json.dumps(response.data.to_dict(), indent=2, default=str))
  ```
</CodeGroup>

**Run the script:**

<CodeGroup>
  ```shell Node.js theme={null}
  npm run check-balance
  ```

  ```shell Python theme={null}
  python check_balance.py
  ```
</CodeGroup>

**Response:**

```json  theme={null}
{
  "tokenBalances": [
    {
      "token": {
        "id": "15dc2b5d-0994-58b0-bf8c-3a0501148ee8",
        "blockchain": "ARC-TESTNET",
        "name": "USDC-TESTNET",
        "symbol": "USDC-TESTNET",
        "decimals": 18,
        "isNative": true,
        "updateDate": "2025-10-03T22:56:09Z",
        "createDate": "2025-09-25T19:41:46Z"
      },
      "amount": "100",
      "updateDate": "2026-01-26T11:00:37Z"
    }
  ]
}
```

***

<Tabs>
  <Tab title="ERC-20">
    ## Deploy an ERC-20 contract

    ERC-20 is the standard for fungible tokens. Use this template for tokenized
    assets, treasury instruments, governance tokens, or programmable money.

    ### Step 3: Prepare for deployment

    #### 3.1. Get your wallet information

    Retrieve your wallet ID from Step 2. Ensure:

    * Wallet custody type is **Dev-Controlled**
    * Blockchain is **Arc Testnet**
    * Account type is **SCA** (Smart Contract Account, recommended) or **EOA**
      (Externally Owned Account)

    Note your wallet's address for subsequent steps.

    #### 3.2. Understand deployment parameters

    | Parameter                | Description                                                                                                                                                      |
    | :----------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `idempotencyKey`         | A unique value to prevent duplicate requests.                                                                                                                    |
    | `name`                   | The offchain contract name (visible in Circle Console only). Use `MyTokenContract`.                                                                              |
    | `walletId`               | The ID of the wallet deploying the contract. Use your dev-controlled wallet ID.                                                                                  |
    | `templateId`             | The template identifier. Use `a1b74add-23e0-4712-88d1-6b3009e85a86` for ERC-20. See [Templates](https://developers.circle.com/contracts/scp-templates-overview). |
    | `blockchain`             | The network to deploy onto. Use `ARC-TESTNET`.                                                                                                                   |
    | `entitySecretCiphertext` | The re-encrypted entity secret. See [Entity Secret Management](https://developers.circle.com/wallets/dev-controlled/entity-secret-management).                   |
    | `feeLevel`               | The fee level for transaction processing. Use `MEDIUM`.                                                                                                          |
    | `templateParameters`     | The onchain initialization parameters (see below).                                                                                                               |

    #### 3.3. Template parameters

    **Required Parameters:**

    | Parameter              | Type   | Description                                                                         |
    | :--------------------- | :----- | :---------------------------------------------------------------------------------- |
    | `name`                 | String | The onchain contract name. Use `MyToken`.                                           |
    | `defaultAdmin`         | String | The address with administrator permissions. Use your Dev-Controlled Wallet address. |
    | `primarySaleRecipient` | String | The address that receives proceeds from first-time sales. Use your wallet address.  |

    **Optional Parameters:**

    | Parameter              | Type       | Description                                                                                                |
    | :--------------------- | :--------- | :--------------------------------------------------------------------------------------------------------- |
    | `symbol`               | String     | The token symbol (for example, `MTK`).                                                                     |
    | `platformFeeRecipient` | String     | The address that receives platform fees from sales. Set this when implementing platform fee revenue share. |
    | `platformFeePercent`   | Float      | The platform fee percentage as decimal (for example, `0.1` for 10%). Requires `platformFeeRecipient`.      |
    | `contractUri`          | String     | The URL for the contract metadata.                                                                         |
    | `trustedForwarders`    | Strings\[] | A list of addresses that can forward ERC2771 meta-transactions to this contract.                           |

    ### Step 4: Deploy the smart contract

    Deploy by making a request to
    [`POST /templates/{id}/deploy`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/deploy-contract-template):

    <CodeGroup>
      ```ts deploy-erc20.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const response = await circleContractSdk.deployContractTemplate({
        id: "a1b74add-23e0-4712-88d1-6b3009e85a86",
        blockchain: "ARC-TESTNET",
        name: "MyTokenContract",
        walletId: process.env.WALLET_ID,
        templateParameters: {
          name: "MyToken",
          symbol: "MTK",
          defaultAdmin: process.env.WALLET_ADDRESS,
          primarySaleRecipient: process.env.WALLET_ADDRESS,
        },
        fee: {
          type: "level",
          config: {
            feeLevel: "MEDIUM",
          },
        },
      });

      console.log(JSON.stringify(response.data, null, 2));
      ```

      ```python deploy_erc20.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      import os
      import json

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.TemplatesApi(scpClient)

      request = smart_contract_platform.TemplateContractDeploymentRequest.from_dict({
          "blockchain": "ARC-TESTNET",
          "name": "MyTokenContract",
          "walletId": os.getenv("WALLET_ID"),
          "templateParameters": {
              "name": "MyToken",
              "symbol": "MTK",
              "defaultAdmin": os.getenv("WALLET_ADDRESS"),
              "primarySaleRecipient": os.getenv("WALLET_ADDRESS"),
          },
          "feeLevel": "MEDIUM"
      })

      response = api_instance.deploy_contract_template("a1b74add-23e0-4712-88d1-6b3009e85a86", request)

      print(json.dumps(response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url https://api.circle.com/v1/w3s/templates/a1b74add-23e0-4712-88d1-6b3009e85a86/deploy \
        --header 'Authorization: Bearer <API_KEY>' \
        --header 'Content-Type: application/json' \
        --data '
      {
        "idempotencyKey": "<string>",
        "entitySecretCiphertext": "<string>",
        "blockchain": "ARC-TESTNET",
        "walletId": "<WALLET_ID>",
        "name": "MyTokenContract",
        "templateParameters": {
          "name": "MyToken",
          "symbol": "MTK",
          "defaultAdmin": "<DEFAULT_ADMIN_ADDRESS>",
          "primarySaleRecipient": "<PRIMARY_SALE_ADDRESS>"
        },
        "feeLevel": "MEDIUM"
      }
      '
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run deploy-erc20
      ```

      ```shell Python theme={null}
      python deploy_erc20.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contractIds": ["019c053d-1ed1-772b-91a8-6970003dad8d"],
      "transactionId": "5b6185b2-f9a1-5645-9db2-ca5d9a330794"
    }
    ```

    <Note>
      A successful response indicates deployment has been **initiated**, not
      completed. Use the `transactionId` to check the deployment status in the next
      step.
    </Note>

    #### 4.1. Check deployment status

    You can check the status of the deployment from the
    [Circle Developer Console](https://console.circle.com/smart-contracts/contracts)
    or by calling
    [`GET /transactions/{id}`](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/get-transaction).

    After running the deployment script, copy the `transactionId` from the response
    and update your `.env` file with `TRANSACTION_ID={your-transaction-id}`. Then
    run the check-transaction script to verify deployment status.

    <CodeGroup>
      ```ts check-transaction.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const transactionResponse = await circleDeveloperSdk.getTransaction({
        id: process.env.TRANSACTION_ID!,
      });

      console.log(JSON.stringify(transactionResponse.data, null, 2));
      ```

      ```python check_transaction.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)
      transaction_response = api_instance.get_transaction(
          id=os.getenv("TRANSACTION_ID")
      )

      print(json.dumps(transaction_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run check-transaction
      ```

      ```shell Python theme={null}
      python check_transaction.py
      ```
    </CodeGroup>

    <Note>
      Transaction status may show PENDING immediately after deployment. Wait 10-30
      seconds and re-run check-transaction to see COMPLETE status.
    </Note>

    **Response:**

    ```json  theme={null}
    {
      "transaction": {
        "id": "601a0815-f749-41d8-b193-22cadd2a8977",
        "blockchain": "ARC-TESTNET",
        "walletId": "45692c3e-2ffa-5c5b-a99c-61366939114c",
        "sourceAddress": "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
        "contractAddress": "0x281156899e5bd6fecf1c0831ee24894eeeaea2f8",
        "transactionType": "OUTBOUND",
        "custodyType": "DEVELOPER",
        "state": "COMPLETE",
        "amounts": [],
        "nfts": null,
        "txHash": "0x3bfbab5d5ce0d1a5d682cbc742d3940cf59db0369d173b71ba2a3b8f43bfbcb1",
        "blockHash": "0x7d12148f9331556b31f84f58a41b7ff16eaaa47940f9e86733037d7ab74d858e",
        "blockHeight": 23686153,
        "userOpHash": "0x66befac1a371fcdddf1566215e4677127e111dff9253f306f7096fed8642a208",
        "networkFee": "0.044628774800664",
        "firstConfirmDate": "2026-01-26T08:59:56Z",
        "operation": "CONTRACT_EXECUTION",
        "feeLevel": "MEDIUM",
        "estimatedFee": {
          "gasLimit": "500797",
          "networkFee": "0.16506442157883425",
          "baseFee": "160",
          "priorityFee": "9.60345525",
          "maxFee": "329.60345525"
        },
        "refId": "",
        "abiFunctionSignature": "mintTo(address,uint256)",
        "abiParameters": [
          "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
          "1000000000000000000"
        ],
        "createDate": "2026-01-26T08:59:54Z",
        "updateDate": "2026-01-26T08:59:56Z"
      }
    }
    ```

    #### 4.2. Get the contract address

    After deployment completes, retrieve the contract address using
    [`GET /contracts/{id}`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/get-contract).

    After deployment completes, copy the `contractIds[0]` from the deployment
    response and update your `.env` file with `CONTRACT_ID={your-contract-id}`. Then
    run the get-contract script to retrieve the contract address.

    <CodeGroup>
      ```ts get-contract.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const contractResponse = await circleContractSdk.getContract({
        id: process.env.CONTRACT_ID!,
      });

      console.log(JSON.stringify(contractResponse.data, null, 2));
      ```

      ```python get_contract.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.ViewUpdateApi(scpClient)
      contract_response = api_instance.get_contract(
          id=os.getenv("CONTRACT_ID")
      )

      print(json.dumps(contract_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run get-contract
      ```

      ```shell Python theme={null}
      python get_contract.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contract": {
        "id": "b7c35372-ce69-4ccd-bfaa-504c14634f0d",
        "contractAddress": "0x1234567890abcdef1234567890abcdef12345678",
        "blockchain": "ARC-TESTNET",
        "status": "COMPLETE"
      }
    }
    ```

    Once your contract is deployed, you can interact with it from your application.
    You'll be able to view the contract both in the
    [Circle Developer Console](https://console.circle.com/smart-contracts/contracts)
    and on the [Arc Testnet Explorer](https://testnet.arcscan.app/).

    <Note>
      **Initial Supply:** The contract starts with 0 token supply at deployment. Use
      the `mintTo` function to create tokens and assign them to addresses as needed.
    </Note>

    ***
  </Tab>

  <Tab title="ERC-721">
    ## Deploy an ERC-721 contract

    ERC-721 is the standard for unique digital assets. Use this template for
    ownership certificates, tokenized assets, unique financial instruments, or
    distinct asset representation.

    ### Step 3: Prepare for deployment

    #### 3.1. Get your wallet information

    Retrieve your wallet ID from Step 2. Ensure:

    * Wallet custody type is **Dev-Controlled**
    * Blockchain is **Arc Testnet**
    * Account type is **SCA** (Smart Contract Account, recommended) or **EOA**
      (Externally Owned Account)

    Note your wallet's address for subsequent steps.

    #### 3.2. Understand deployment parameters

    | Parameter                | Description                                                                                                                                                       |
    | :----------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `idempotencyKey`         | A unique value to prevent duplicate requests.                                                                                                                     |
    | `name`                   | The offchain contract name (visible in Circle Console only). Use `MyTokenContract`.                                                                               |
    | `walletId`               | The ID of the wallet deploying the contract. Use your dev-controlled wallet ID.                                                                                   |
    | `templateId`             | The template identifier. Use `76b83278-50e2-4006-8b63-5b1a2a814533` for ERC-721. See [Templates](https://developers.circle.com/contracts/scp-templates-overview). |
    | `blockchain`             | The network to deploy onto. Use `ARC-TESTNET`.                                                                                                                    |
    | `entitySecretCiphertext` | The re-encrypted entity secret. See [Entity Secret Management](https://developers.circle.com/wallets/dev-controlled/entity-secret-management).                    |
    | `feeLevel`               | The fee level for transaction processing. Use `MEDIUM`.                                                                                                           |
    | `templateParameters`     | The onchain initialization parameters (see below).                                                                                                                |

    #### 3.3. Template parameters

    **Required Parameters:**

    | Parameter              | Type   | Description                                                                         |
    | :--------------------- | :----- | :---------------------------------------------------------------------------------- |
    | `name`                 | String | The onchain contract name. Use `MyToken`.                                           |
    | `defaultAdmin`         | String | The address with administrator permissions. Use your Dev-Controlled Wallet address. |
    | `primarySaleRecipient` | String | The address for first-time sale proceeds. Use your Dev-Controlled Wallet address.   |
    | `royaltyRecipient`     | String | The address for secondary sale royalties. Use your Dev-Controlled Wallet address.   |
    | `royaltyPercent`       | Float  | The royalty share as a decimal (for example, `0.01` for 1%). Use `0.01`.            |

    **Optional Parameters:**

    | Parameter              | Type       | Description                                                                                                |
    | :--------------------- | :--------- | :--------------------------------------------------------------------------------------------------------- |
    | `symbol`               | String     | The token symbol (for example, `MTK`).                                                                     |
    | `platformFeeRecipient` | String     | The address that receives platform fees from sales. Set this when implementing platform fee revenue share. |
    | `platformFeePercent`   | Float      | The platform fee percentage as decimal (for example, `0.1` for 10%). Requires `platformFeeRecipient`.      |
    | `contractUri`          | String     | The URL for the contract metadata.                                                                         |
    | `trustedForwarders`    | Strings\[] | A list of addresses that can forward ERC2771 meta-transactions to this contract.                           |

    ### Step 4: Deploy the smart contract

    Deploy by making a request to
    [`POST /templates/{id}/deploy`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/deploy-contract-template):

    <CodeGroup>
      ```ts deploy-erc721.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const response = await circleContractSdk.deployContractTemplate({
        id: "76b83278-50e2-4006-8b63-5b1a2a814533",
        blockchain: "ARC-TESTNET",
        name: "MyTokenContract",
        walletId: process.env.WALLET_ID,
        templateParameters: {
          name: "MyToken",
          symbol: "MTK",
          defaultAdmin: process.env.WALLET_ADDRESS,
          primarySaleRecipient: process.env.WALLET_ADDRESS,
          royaltyRecipient: process.env.WALLET_ADDRESS,
          royaltyPercent: 0.01,
        },
        fee: {
          type: "level",
          config: {
            feeLevel: "MEDIUM",
          },
        },
      });

      console.log(JSON.stringify(response.data, null, 2));
      ```

      ```python deploy_erc721.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      import os
      import json

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.TemplatesApi(scpClient)

      request = smart_contract_platform.TemplateContractDeploymentRequest.from_dict({
          "blockchain": "ARC-TESTNET",
          "name": "MyTokenContract",
          "walletId": os.getenv("WALLET_ID"),
          "templateParameters": {
              "name": "MyToken",
              "symbol": "MTK",
              "defaultAdmin": os.getenv("WALLET_ADDRESS"),
              "primarySaleRecipient": os.getenv("WALLET_ADDRESS"),
              "royaltyRecipient": os.getenv("WALLET_ADDRESS"),
              "royaltyPercent": "0.01",
          },
          "feeLevel": "MEDIUM"
      })

      request.template_parameters["royaltyPercent"] = 0.01

      response = api_instance.deploy_contract_template("76b83278-50e2-4006-8b63-5b1a2a814533", request)

      print(json.dumps(response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url https://api.circle.com/v1/w3s/templates/76b83278-50e2-4006-8b63-5b1a2a814533/deploy \
        --header 'Authorization: Bearer <API_KEY>' \
        --header 'Content-Type: application/json' \
        --data '
      {
        "idempotencyKey": "<string>",
        "entitySecretCiphertext": "<string>",
        "blockchain": "ARC-TESTNET",
        "walletId": "<WALLET_ID>",
        "name": "MyTokenContract",
        "templateParameters": {
          "name": "MyToken",
          "symbol": "MTK",
          "defaultAdmin": "<WALLET_ADDRESS>",
          "primarySaleRecipient": "<WALLET_ADDRESS>",
          "royaltyRecipient": "<WALLET_ADDRESS>",
          "royaltyPercent": 0.01
        },
        "feeLevel": "MEDIUM"
      }
      '
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run deploy-erc721
      ```

      ```shell Python theme={null}
      python deploy_erc721.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contractIds": ["019c053d-1ed1-772b-91a8-6970003dad8d"],
      "transactionId": "5b6185b2-f9a1-5645-9db2-ca5d9a330794"
    }
    ```

    <Note>
      A successful response indicates deployment has been **initiated**, not
      completed. Use the `transactionId` to check the deployment status in the next
      step.
    </Note>

    #### 4.1. Check deployment status

    Verify deployment with
    [`GET /transactions/{id}`](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/get-transaction).

    After running the deployment script, copy the `transactionId` from the response
    and update your `.env` file with `TRANSACTION_ID={your-transaction-id}`. Then
    run the check-transaction script to verify deployment status.

    <CodeGroup>
      ```ts check-transaction.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const transactionResponse = await circleDeveloperSdk.getTransaction({
        id: process.env.TRANSACTION_ID!,
      });

      console.log(JSON.stringify(transactionResponse.data, null, 2));
      ```

      ```python check_transaction.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)
      transaction_response = api_instance.get_transaction(
          id=os.getenv("TRANSACTION_ID")
      )

      print(json.dumps(transaction_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run check-transaction
      ```

      ```shell Python theme={null}
      python check_transaction.py
      ```
    </CodeGroup>

    <Note>
      Transaction status may show PENDING immediately after deployment. Wait 10-30
      seconds and re-run check-transaction to see COMPLETE status.
    </Note>

    **Response:**

    ```json  theme={null}
    {
      "transaction": {
        "id": "601a0815-f749-41d8-b193-22cadd2a8977",
        "blockchain": "ARC-TESTNET",
        "walletId": "45692c3e-2ffa-5c5b-a99c-61366939114c",
        "sourceAddress": "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
        "contractAddress": "0x281156899e5bd6fecf1c0831ee24894eeeaea2f8",
        "transactionType": "OUTBOUND",
        "custodyType": "DEVELOPER",
        "state": "COMPLETE",
        "amounts": [],
        "nfts": null,
        "txHash": "0x3bfbab5d5ce0d1a5d682cbc742d3940cf59db0369d173b71ba2a3b8f43bfbcb1",
        "blockHash": "0x7d12148f9331556b31f84f58a41b7ff16eaaa47940f9e86733037d7ab74d858e",
        "blockHeight": 23686153,
        "userOpHash": "0x66befac1a371fcdddf1566215e4677127e111dff9253f306f7096fed8642a208",
        "networkFee": "0.044628774800664",
        "firstConfirmDate": "2026-01-26T08:59:56Z",
        "operation": "CONTRACT_EXECUTION",
        "feeLevel": "MEDIUM",
        "estimatedFee": {
          "gasLimit": "500797",
          "networkFee": "0.16506442157883425",
          "baseFee": "160",
          "priorityFee": "9.60345525",
          "maxFee": "329.60345525"
        },
        "refId": "",
        "abiFunctionSignature": "mintTo(address,uint256)",
        "abiParameters": [
          "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
          "1000000000000000000"
        ],
        "createDate": "2026-01-26T08:59:54Z",
        "updateDate": "2026-01-26T08:59:56Z"
      }
    }
    ```

    #### 4.2. Get the contract address

    After deployment completes, retrieve the contract address using
    [`GET /contracts/{id}`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/get-contract).

    After deployment completes, copy the `contractIds[0]` from the deployment
    response and update your `.env` file with `CONTRACT_ID={your-contract-id}`. Then
    run the get-contract script to retrieve the contract address.

    <CodeGroup>
      ```ts get-contract.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const contractResponse = await circleContractSdk.getContract({
        id: process.env.CONTRACT_ID!,
      });

      console.log(JSON.stringify(contractResponse.data, null, 2));
      ```

      ```python get_contract.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.ViewUpdateApi(scpClient)
      contract_response = api_instance.get_contract(
          id=os.getenv("CONTRACT_ID")
      )

      print(json.dumps(contract_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run get-contract
      ```

      ```shell Python theme={null}
      python get_contract.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contract": {
        "id": "b7c35372-ce69-4ccd-bfaa-504c14634f0d",
        "contractAddress": "0x1234567890abcdef1234567890abcdef12345678",
        "blockchain": "ARC-TESTNET",
        "status": "COMPLETE"
      }
    }
    ```

    ***
  </Tab>

  <Tab title="ERC-1155">
    ## Deploy an ERC-1155 contract

    ERC-1155 is the standard for multi-asset token management. Use this template for
    structured products, tiered assets, batch settlements, or managing diverse asset
    portfolios.

    ### Step 3: Prepare for deployment

    #### 3.1. Get your wallet information

    Retrieve your wallet ID from Step 2. Ensure:

    * Wallet custody type is **Dev-Controlled**
    * Blockchain is **Arc Testnet**
    * Account type is **SCA** (Smart Contract Account, recommended) or **EOA**
      (Externally Owned Account)

    Note your wallet's address for subsequent steps.

    #### 3.2. Understand deployment parameters

    | Parameter                | Description                                                                                                                                                        |
    | :----------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `idempotencyKey`         | A unique value to prevent duplicate requests.                                                                                                                      |
    | `name`                   | The offchain contract name (visible in Circle Console only). Use `MyMultiTokenContract`.                                                                           |
    | `walletId`               | The ID of the wallet deploying the contract. Use your dev-controlled wallet ID.                                                                                    |
    | `templateId`             | The template identifier. Use `aea21da6-0aa2-4971-9a1a-5098842b1248` for ERC-1155. See [Templates](https://developers.circle.com/contracts/scp-templates-overview). |
    | `blockchain`             | The network to deploy onto. Use `ARC-TESTNET`.                                                                                                                     |
    | `entitySecretCiphertext` | The re-encrypted entity secret. See [Entity Secret Management](https://developers.circle.com/wallets/dev-controlled/entity-secret-management).                     |
    | `feeLevel`               | The fee level for transaction processing. Use `MEDIUM`.                                                                                                            |
    | `templateParameters`     | The onchain initialization parameters (see below).                                                                                                                 |

    #### 3.3. Template parameters

    **Required Parameters:**

    | Parameter              | Type   | Description                                                                         |
    | :--------------------- | :----- | :---------------------------------------------------------------------------------- |
    | `name`                 | String | The onchain contract name. Use `MyMultiToken`.                                      |
    | `defaultAdmin`         | String | The address with administrator permissions. Use your Dev-Controlled Wallet address. |
    | `primarySaleRecipient` | String | The address for first-time sale proceeds. Use your Dev-Controlled Wallet address.   |
    | `royaltyRecipient`     | String | The address for secondary sale royalties. Use your Dev-Controlled Wallet address.   |
    | `royaltyPercent`       | Float  | The royalty share as a decimal (for example, `0.01` for 1%). Use `0.01`.            |

    **Optional Parameters:**

    | Parameter              | Type       | Description                                                                                                |
    | :--------------------- | :--------- | :--------------------------------------------------------------------------------------------------------- |
    | `symbol`               | String     | The token symbol (for example, `MMTK`).                                                                    |
    | `platformFeeRecipient` | String     | The address that receives platform fees from sales. Set this when implementing platform fee revenue share. |
    | `platformFeePercent`   | Float      | The platform fee percentage as decimal (for example, `0.1` for 10%). Requires `platformFeeRecipient`.      |
    | `contractUri`          | String     | The URL for the contract metadata.                                                                         |
    | `trustedForwarders`    | Strings\[] | A list of addresses that can forward ERC2771 meta-transactions to this contract.                           |

    ### Step 4: Deploy the smart contract

    Deploy by making a request to
    [`POST /templates/{id}/deploy`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/deploy-contract-template):

    <CodeGroup>
      ```ts deploy-erc1155.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const response = await circleContractSdk.deployContractTemplate({
        id: "aea21da6-0aa2-4971-9a1a-5098842b1248",
        blockchain: "ARC-TESTNET",
        name: "MyMultiTokenContract",
        walletId: process.env.WALLET_ID,
        templateParameters: {
          name: "MyMultiToken",
          symbol: "MMTK",
          defaultAdmin: process.env.WALLET_ADDRESS,
          primarySaleRecipient: process.env.WALLET_ADDRESS,
          royaltyRecipient: process.env.WALLET_ADDRESS,
          royaltyPercent: 0.01,
        },
        fee: {
          type: "level",
          config: {
            feeLevel: "MEDIUM",
          },
        },
      });

      console.log(JSON.stringify(response.data, null, 2));
      ```

      ```python deploy_erc1155.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      import os
      import json

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.TemplatesApi(scpClient)

      request = smart_contract_platform.TemplateContractDeploymentRequest.from_dict({
          "blockchain": "ARC-TESTNET",
          "name": "MyMultiTokenContract",
          "walletId": os.getenv("WALLET_ID"),
          "templateParameters": {
              "name": "MyMultiToken",
              "symbol": "MMTK",
              "defaultAdmin": os.getenv("WALLET_ADDRESS"),
              "primarySaleRecipient": os.getenv("WALLET_ADDRESS"),
              "royaltyRecipient": os.getenv("WALLET_ADDRESS"),
              "royaltyPercent": "0.01",
          },
          "feeLevel": "MEDIUM"
      })

      request.template_parameters["royaltyPercent"] = 0.01

      response = api_instance.deploy_contract_template("aea21da6-0aa2-4971-9a1a-5098842b1248", request)

      print(json.dumps(response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url https://api.circle.com/v1/w3s/templates/aea21da6-0aa2-4971-9a1a-5098842b1248/deploy \
        --header 'Authorization: Bearer <API_KEY>' \
        --header 'Content-Type: application/json' \
        --data '
      {
        "idempotencyKey": "<string>",
        "entitySecretCiphertext": "<string>",
        "blockchain": "ARC-TESTNET",
        "walletId": "<WALLET_ID>",
        "name": "MyMultiTokenContract",
        "templateParameters": {
          "name": "MyMultiToken",
          "symbol": "MMTK",
          "defaultAdmin": "<WALLET_ADDRESS>",
          "primarySaleRecipient": "<WALLET_ADDRESS>",
          "royaltyRecipient": "<WALLET_ADDRESS>",
          "royaltyPercent": 0.01
        },
        "feeLevel": "MEDIUM"
      }
      '
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run deploy-erc1155
      ```

      ```shell Python theme={null}
      python deploy_erc1155.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contractIds": ["019c053d-1ed1-772b-91a8-6970003dad8d"],
      "transactionId": "5b6185b2-f9a1-5645-9db2-ca5d9a330794"
    }
    ```

    <Note>
      A successful response indicates deployment has been **initiated**, not
      completed. Use the `transactionId` to check the deployment status in the next
      step.
    </Note>

    #### 4.1. Check deployment status

    Verify deployment with
    [`GET /transactions/{id}`](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/get-transaction).

    After running the deployment script, copy the `transactionId` from the response
    and update your `.env` file with `TRANSACTION_ID={your-transaction-id}`. Then
    run the check-transaction script to verify deployment status.

    <CodeGroup>
      ```ts check-transaction.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const transactionResponse = await circleDeveloperSdk.getTransaction({
        id: process.env.TRANSACTION_ID!,
      });

      console.log(JSON.stringify(transactionResponse.data, null, 2));
      ```

      ```python check_transaction.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)
      transaction_response = api_instance.get_transaction(
          id=os.getenv("TRANSACTION_ID")
      )

      print(json.dumps(transaction_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run check-transaction
      ```

      ```shell Python theme={null}
      python check_transaction.py
      ```
    </CodeGroup>

    <Note>
      Transaction status may show PENDING immediately after deployment. Wait 10-30
      seconds and re-run check-transaction to see COMPLETE status.
    </Note>

    **Response:**

    ```json  theme={null}
    {
      "transaction": {
        "id": "601a0815-f749-41d8-b193-22cadd2a8977",
        "blockchain": "ARC-TESTNET",
        "walletId": "45692c3e-2ffa-5c5b-a99c-61366939114c",
        "sourceAddress": "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
        "contractAddress": "0x281156899e5bd6fecf1c0831ee24894eeeaea2f8",
        "transactionType": "OUTBOUND",
        "custodyType": "DEVELOPER",
        "state": "COMPLETE",
        "amounts": [],
        "nfts": null,
        "txHash": "0x3bfbab5d5ce0d1a5d682cbc742d3940cf59db0369d173b71ba2a3b8f43bfbcb1",
        "blockHash": "0x7d12148f9331556b31f84f58a41b7ff16eaaa47940f9e86733037d7ab74d858e",
        "blockHeight": 23686153,
        "userOpHash": "0x66befac1a371fcdddf1566215e4677127e111dff9253f306f7096fed8642a208",
        "networkFee": "0.044628774800664",
        "firstConfirmDate": "2026-01-26T08:59:56Z",
        "operation": "CONTRACT_EXECUTION",
        "feeLevel": "MEDIUM",
        "estimatedFee": {
          "gasLimit": "500797",
          "networkFee": "0.16506442157883425",
          "baseFee": "160",
          "priorityFee": "9.60345525",
          "maxFee": "329.60345525"
        },
        "refId": "",
        "abiFunctionSignature": "mintTo(address,uint256)",
        "abiParameters": [
          "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
          "1000000000000000000"
        ],
        "createDate": "2026-01-26T08:59:54Z",
        "updateDate": "2026-01-26T08:59:56Z"
      }
    }
    ```

    #### 4.2. Get the contract address

    After deployment completes, retrieve the contract address using
    [`GET /contracts/{id}`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/get-contract).

    After deployment completes, copy the `contractIds[0]` from the deployment
    response and update your `.env` file with `CONTRACT_ID={your-contract-id}`. Then
    run the get-contract script to retrieve the contract address.

    <CodeGroup>
      ```ts get-contract.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const contractResponse = await circleContractSdk.getContract({
        id: process.env.CONTRACT_ID!,
      });

      console.log(JSON.stringify(contractResponse.data, null, 2));
      ```

      ```python get_contract.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.ViewUpdateApi(scpClient)
      contract_response = api_instance.get_contract(
          id=os.getenv("CONTRACT_ID")
      )

      print(json.dumps(contract_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run get-contract
      ```

      ```shell Python theme={null}
      python get_contract.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contract": {
        "id": "b7c35372-ce69-4ccd-bfaa-504c14634f0d",
        "contractAddress": "0x1234567890abcdef1234567890abcdef12345678",
        "blockchain": "ARC-TESTNET",
        "status": "COMPLETE"
      }
    }
    ```

    ***
  </Tab>

  <Tab title="Airdrop">
    ## Deploy an airdrop contract

    The Airdrop template enables mass token distribution to many recipients. Use
    this template for treasury distributions, stakeholder settlements, operational
    payments, or programmatic capital allocation.

    ### Step 3: Prepare for deployment

    #### 3.1. Get your wallet information

    Retrieve your wallet ID from Step 2. Ensure:

    * Wallet custody type is **Dev-Controlled**
    * Blockchain is **Arc Testnet**
    * Account type is **SCA** (Smart Contract Account, recommended) or **EOA**
      (Externally Owned Account)

    Note your wallet's address for subsequent steps.

    #### 3.2. Understand deployment parameters

    | Parameter                | Description                                                                                                                                                       |
    | :----------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | `idempotencyKey`         | A unique value to prevent duplicate requests.                                                                                                                     |
    | `name`                   | The offchain contract name (visible in Circle Console only). Use `MyAirdropContract`.                                                                             |
    | `walletId`               | The ID of the wallet deploying the contract. Use your dev-controlled wallet ID.                                                                                   |
    | `templateId`             | The template identifier. Use `13e322f2-18dc-4f57-8eed-4bddfc50f85e` for Airdrop. See [Templates](https://developers.circle.com/contracts/scp-templates-overview). |
    | `blockchain`             | The network to deploy onto. Use `ARC-TESTNET`.                                                                                                                    |
    | `entitySecretCiphertext` | The re-encrypted entity secret. See [Entity Secret Management](https://developers.circle.com/wallets/dev-controlled/entity-secret-management).                    |
    | `feeLevel`               | The fee level for transaction processing. Use `MEDIUM`.                                                                                                           |
    | `templateParameters`     | The onchain initialization parameters (see below).                                                                                                                |

    #### 3.3. Template parameters

    **Required Parameters:**

    | Parameter      | Type   | Description                                                                         |
    | :------------- | :----- | :---------------------------------------------------------------------------------- |
    | `defaultAdmin` | String | The address with administrator permissions. Use your Dev-Controlled Wallet address. |

    **Optional Parameters:**

    | Parameter     | Type   | Description                        |
    | :------------ | :----- | :--------------------------------- |
    | `contractURI` | String | The URL for the contract metadata. |

    ### Step 4: Deploy the smart contract

    Deploy by making a request to
    [`POST /templates/{id}/deploy`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/deploy-contract-template):

    <CodeGroup>
      ```ts deploy-airdrop.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const response = await circleContractSdk.deployContractTemplate({
        id: "13e322f2-18dc-4f57-8eed-4bddfc50f85e",
        blockchain: "ARC-TESTNET",
        name: "MyAirdropContract",
        walletId: process.env.WALLET_ID,
        templateParameters: {
          defaultAdmin: process.env.WALLET_ADDRESS,
        },
        fee: {
          type: "level",
          config: {
            feeLevel: "MEDIUM",
          },
        },
      });

      console.log(JSON.stringify(response.data, null, 2));
      ```

      ```python deploy_airdrop.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      import os
      import json

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.TemplatesApi(scpClient)

      request = smart_contract_platform.TemplateContractDeploymentRequest.from_dict({
          "blockchain": "ARC-TESTNET",
          "name": "MyAirdropContract",
          "walletId": os.getenv("WALLET_ID"),
          "templateParameters": {
              "defaultAdmin": os.getenv("WALLET_ADDRESS"),
          },
          "feeLevel": "MEDIUM"
      })

      response = api_instance.deploy_contract_template("13e322f2-18dc-4f57-8eed-4bddfc50f85e", request)

      print(json.dumps(response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url https://api.circle.com/v1/w3s/templates/13e322f2-18dc-4f57-8eed-4bddfc50f85e/deploy \
        --header 'Authorization: Bearer <API_KEY>' \
        --header 'Content-Type: application/json' \
        --data '
      {
        "idempotencyKey": "<string>",
        "entitySecretCiphertext": "<string>",
        "blockchain": "ARC-TESTNET",
        "walletId": "<WALLET_ID>",
        "name": "MyAirdropContract",
        "templateParameters": {
          "defaultAdmin": "<WALLET_ADDRESS>"
        },
        "feeLevel": "MEDIUM"
      }
      '
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run deploy-airdrop
      ```

      ```shell Python theme={null}
      python deploy_airdrop.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contractIds": ["019c053d-1ed1-772b-91a8-6970003dad8d"],
      "transactionId": "5b6185b2-f9a1-5645-9db2-ca5d9a330794"
    }
    ```

    <Note>
      A successful response indicates deployment has been **initiated**, not
      completed. Use the `transactionId` to check the deployment status in the next
      step.
    </Note>

    #### 4.1. Check deployment status

    Verify deployment with
    [`GET /transactions/{id}`](https://developers.circle.com/api-reference/wallets/developer-controlled-wallets/get-transaction).

    After running the deployment script, copy the `transactionId` from the response
    and update your `.env` file with `TRANSACTION_ID={your-transaction-id}`. Then
    run the check-transaction script to verify deployment status.

    <CodeGroup>
      ```ts check-transaction.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const transactionResponse = await circleDeveloperSdk.getTransaction({
        id: process.env.TRANSACTION_ID!,
      });

      console.log(JSON.stringify(transactionResponse.data, null, 2));
      ```

      ```python check_transaction.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)
      transaction_response = api_instance.get_transaction(
          id=os.getenv("TRANSACTION_ID")
      )

      print(json.dumps(transaction_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run check-transaction
      ```

      ```shell Python theme={null}
      python check_transaction.py
      ```
    </CodeGroup>

    <Note>
      Transaction status may show PENDING immediately after deployment. Wait 10-30
      seconds and re-run check-transaction to see COMPLETE status.
    </Note>

    **Response:**

    ```json  theme={null}
    {
      "transaction": {
        "id": "601a0815-f749-41d8-b193-22cadd2a8977",
        "blockchain": "ARC-TESTNET",
        "walletId": "45692c3e-2ffa-5c5b-a99c-61366939114c",
        "sourceAddress": "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
        "contractAddress": "0x281156899e5bd6fecf1c0831ee24894eeeaea2f8",
        "transactionType": "OUTBOUND",
        "custodyType": "DEVELOPER",
        "state": "COMPLETE",
        "amounts": [],
        "nfts": null,
        "txHash": "0x3bfbab5d5ce0d1a5d682cbc742d3940cf59db0369d173b71ba2a3b8f43bfbcb1",
        "blockHash": "0x7d12148f9331556b31f84f58a41b7ff16eaaa47940f9e86733037d7ab74d858e",
        "blockHeight": 23686153,
        "userOpHash": "0x66befac1a371fcdddf1566215e4677127e111dff9253f306f7096fed8642a208",
        "networkFee": "0.044628774800664",
        "firstConfirmDate": "2026-01-26T08:59:56Z",
        "operation": "CONTRACT_EXECUTION",
        "feeLevel": "MEDIUM",
        "estimatedFee": {
          "gasLimit": "500797",
          "networkFee": "0.16506442157883425",
          "baseFee": "160",
          "priorityFee": "9.60345525",
          "maxFee": "329.60345525"
        },
        "refId": "",
        "abiFunctionSignature": "mintTo(address,uint256)",
        "abiParameters": [
          "0xbcf83d3b112cbf43b19904e376dd8dee01fe2758",
          "1000000000000000000"
        ],
        "createDate": "2026-01-26T08:59:54Z",
        "updateDate": "2026-01-26T08:59:56Z"
      }
    }
    ```

    #### 4.2. Get the contract address

    After deployment completes, retrieve the contract address using
    [`GET /contracts/{id}`](https://developers.circle.com/api-reference/contracts/smart-contract-platform/get-contract).

    After deployment completes, copy the `contractIds[0]` from the deployment
    response and update your `.env` file with `CONTRACT_ID={your-contract-id}`. Then
    run the get-contract script to retrieve the contract address.

    <CodeGroup>
      ```ts get-contract.ts theme={null}
      import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

      const circleContractSdk = initiateSmartContractPlatformClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const contractResponse = await circleContractSdk.getContract({
        id: process.env.CONTRACT_ID!,
      });

      console.log(JSON.stringify(contractResponse.data, null, 2));
      ```

      ```python get_contract.py theme={null}
      from circle.web3 import utils, smart_contract_platform
      from pathlib import Path
      from dotenv import load_dotenv
      import os
      import json

      # Load environment variables
      env_path = Path(__file__).resolve().parent / ".env"
      load_dotenv(env_path)

      scpClient = utils.init_smart_contract_platform_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = smart_contract_platform.ViewUpdateApi(scpClient)
      contract_response = api_instance.get_contract(
          id=os.getenv("CONTRACT_ID")
      )

      print(json.dumps(contract_response.data.to_dict(), indent=2, default=str))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run get-contract
      ```

      ```shell Python theme={null}
      python get_contract.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "contract": {
        "id": "b7c35372-ce69-4ccd-bfaa-504c14634f0d",
        "contractAddress": "0x1234567890abcdef1234567890abcdef12345678",
        "blockchain": "ARC-TESTNET",
        "status": "COMPLETE"
      }
    }
    ```

    ***
  </Tab>
</Tabs>

***

## Summary

After completing this tutorial, you've successfully:

* Created a dev-controlled wallet on Arc Testnet
* Funded your wallet with testnet USDC
* Deployed a smart contract using Contract Templates
* Retrieved your contract address


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Interact with contracts

> Execute contract functions on Arc Testnet to mint tokens, transfer assets, and perform contract operations.

This tutorial guides you through interacting with smart contracts deployed on
Arc Testnet. You'll learn how to execute contract functions like minting tokens,
transferring assets, and performing contract-specific operations for ERC-20,
ERC-721, ERC-1155, and Airdrop contracts.

## Prerequisites

Complete the [Deploy contracts](/arc/tutorials/deploy-contracts) tutorial first.
You'll need a deployed contract and funded wallet.

## Step 1: Set up tutorial scripts

### Update your environment variables

Add this new variable to your existing `.env` file (from the Deploy contracts
tutorial):

```shell  theme={null}
echo "RECIPIENT_WALLET_ADDRESS={RECIPIENT_ADDRESS_FOR_TRANSFERS}" >> .env
```

<Note>
  Your `.env` file should already have `CIRCLE_API_KEY`, `CIRCLE_ENTITY_SECRET`,
  `WALLET_ID`, `WALLET_ADDRESS`, and `CONTRACT_ADDRESS` from the Deploy
  contracts tutorial. You're only adding 1 new variable here.
</Note>

### Add npm scripts

Add run scripts for contract interactions to your `package.json`:

```shell  theme={null}
npm pkg set scripts.interact-erc20="tsx --env-file=.env interact-erc20.ts"
npm pkg set scripts.interact-erc721="tsx --env-file=.env interact-erc721.ts"
npm pkg set scripts.interact-erc1155="tsx --env-file=.env interact-erc1155.ts"
npm pkg set scripts.interact-airdrop="tsx --env-file=.env interact-airdrop.ts"
```

## Step 2: Interact with contracts

Select the contract type you want to interact with from the tabs below.

<Tabs>
  <Tab title="ERC-20">
    ## Interact with ERC-20 contracts

    ERC-20 tokens support standard fungible token operations. You'll learn to mint
    new tokens and transfer them between addresses.

    ### Mint tokens

    Use the `mintTo` function to mint tokens. The wallet must have `MINTER_ROLE`.

    <CodeGroup>
      ```ts Node.js theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const mintResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "mintTo(address,uint256)",
          abiParameters: [
            process.env.WALLET_ADDRESS,
            "1000000000000000000", // 1 token with 18 decimals
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(mintResponse.data, null, 2));
      ```

      ```python Python theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      mint_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "mintTo(address,uint256)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              "1000000000000000000"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      mint_response = api_instance.create_developer_transaction_contract_execution(mint_request)

      print(json.dumps(mint_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "mintTo(address,uint256)",
          "abiParameters": [
            "<WALLET_ADDRESS>",
            "1000000000000000000"
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```

    <Note>
      **Token decimals**: ERC-20 tokens typically use 18 decimals. To mint 1 token,
      use `1000000000000000000` (1 × 10^18).
    </Note>

    ### Transfer tokens

    Use the `transfer` function to send tokens to another address.

    <CodeGroup>
      ```ts Node.js theme={null}
      const transferResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "transfer(address,uint256)",
          abiParameters: [
            process.env.RECIPIENT_WALLET_ADDRESS,
            "1000000000000000000", // 1 token with 18 decimals
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(transferResponse.data, null, 2));
      ```

      ```python Python theme={null}
      transfer_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "transfer(address,uint256)",
          "abiParameters": [
              os.getenv("RECIPIENT_WALLET_ADDRESS"),
              "1000000000000000000"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      transfer_response = api_instance.create_developer_transaction_contract_execution(transfer_request)

      print(json.dumps(transfer_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "transfer(address,uint256)",
          "abiParameters": [
            "<RECIPIENT_ADDRESS>",
            "1000000000000000000"
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```

    ### Complete script

    Here's the complete script combining mint and transfer operations:

    <CodeGroup>
      ```ts interact-erc20.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      async function main() {
        // Mint tokens
        const mintResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature: "mintTo(address,uint256)",
            abiParameters: [
              process.env.WALLET_ADDRESS,
              "1000000000000000000", // 1 token with 18 decimals
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(mintResponse.data, null, 2));

        // Transfer tokens
        const transferResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature: "transfer(address,uint256)",
            abiParameters: [
              process.env.RECIPIENT_WALLET_ADDRESS,
              "1000000000000000000", // 1 token with 18 decimals
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(transferResponse.data, null, 2));
      }

      main();
      ```

      ```python interact_erc20.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      # Mint tokens
      mint_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "mintTo(address,uint256)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              "1000000000000000000"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      mint_response = api_instance.create_developer_transaction_contract_execution(mint_request)
      print(json.dumps(mint_response.data.to_dict(), indent=2))

      # Transfer tokens
      transfer_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "transfer(address,uint256)",
          "abiParameters": [
              os.getenv("RECIPIENT_WALLET_ADDRESS"),
              "1000000000000000000"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      transfer_response = api_instance.create_developer_transaction_contract_execution(transfer_request)
      print(json.dumps(transfer_response.data.to_dict(), indent=2))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run interact-erc20
      ```

      ```shell Python theme={null}
      python interact_erc20.py
      ```
    </CodeGroup>
  </Tab>

  <Tab title="ERC-721">
    ## Interact with ERC-721 contracts

    ERC-721 tokens are unique tokens. Each token has a unique ID and can have
    associated metadata stored on IPFS or other storage.

    ### Mint tokens

    Use the `mintTo` function to mint tokens. The wallet must have `MINTER_ROLE`.

    <CodeGroup>
      ```ts Node.js theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const mintResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "mintTo(address,string)",
          abiParameters: [
            process.env.WALLET_ADDRESS,
            "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(mintResponse.data, null, 2));
      ```

      ```python Python theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      mint_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "mintTo(address,string)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      mint_response = api_instance.create_developer_transaction_contract_execution(mint_request)

      print(json.dumps(mint_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "mintTo(address,string)",
          "abiParameters": [
            "<WALLET_ADDRESS>",
            "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei"
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```

    <Note>
      **Metadata URI**: The second parameter is the token metadata URI. It typically
      points to an IPFS hash containing the token's metadata (name, description,
      image, etc.). You can use the example IPFS URI from the code sample for
      testing.
    </Note>

    ### Transfer tokens

    Use the `transferFrom` or `safeTransferFrom` function to transfer tokens between
    addresses.

    <CodeGroup>
      ```ts Node.js theme={null}
      const transferResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "safeTransferFrom(address,address,uint256)",
          abiParameters: [
            "<FROM_ADDRESS>",
            "<TO_ADDRESS>",
            "1", // Token ID
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(transferResponse.data, null, 2));
      ```

      ```python Python theme={null}
      transfer_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "safeTransferFrom(address,address,uint256)",
          "abiParameters": [
              "<FROM_ADDRESS>",
              "<TO_ADDRESS>",
              "1"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      transfer_response = api_instance.create_developer_transaction_contract_execution(transfer_request)

      print(json.dumps(transfer_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "safeTransferFrom(address,address,uint256)",
          "abiParameters": [
            "<FROM_ADDRESS>",
            "<TO_ADDRESS>",
            "1"
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    ### Complete script

    Here's the complete script combining mint and transfer operations:

    <CodeGroup>
      ```ts interact-erc721.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      async function main() {
        // Mint token
        const mintResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature: "mintTo(address,string)",
            abiParameters: [
              process.env.WALLET_ADDRESS,
              "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(mintResponse.data, null, 2));

        // Transfer token (token ID 1)
        const transferResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature: "safeTransferFrom(address,address,uint256)",
            abiParameters: [
              process.env.WALLET_ADDRESS,
              process.env.RECIPIENT_WALLET_ADDRESS,
              "1", // Token ID
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(transferResponse.data, null, 2));
      }

      main();
      ```

      ```python interact_erc721.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      # Mint token
      mint_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "mintTo(address,string)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      mint_response = api_instance.create_developer_transaction_contract_execution(mint_request)
      print(json.dumps(mint_response.data.to_dict(), indent=2))

      # Transfer token (token ID 1)
      transfer_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "safeTransferFrom(address,address,uint256)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              os.getenv("RECIPIENT_WALLET_ADDRESS"),
              "1"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      transfer_response = api_instance.create_developer_transaction_contract_execution(transfer_request)
      print(json.dumps(transfer_response.data.to_dict(), indent=2))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run interact-erc721
      ```

      ```shell Python theme={null}
      python interact_erc721.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```
  </Tab>

  <Tab title="ERC-1155">
    ## Interact with ERC-1155 contracts

    ERC-1155 contracts support multiple token types in a single contract. Each token
    has a unique ID and can be fungible or non-fungible.

    ### Mint tokens

    Use the `mintTo` function to mint tokens. The wallet must have `MINTER_ROLE`.
    The first mint requires the maximum uint256 value to create token ID 0. For
    subsequent mints, always use `0` which creates the next token ID.

    <CodeGroup>
      ```ts Node.js theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const mintResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "mintTo(address,uint256,string,uint256)",
          abiParameters: [
            process.env.WALLET_ADDRESS,
            "115792089237316195423570985008687907853269984665640564039457584007913129639935", // Max uint256 = ID 0
            "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
            "1", // Amount
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(mintResponse.data, null, 2));
      ```

      ```python Python theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      mint_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "mintTo(address,uint256,string,uint256)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              "115792089237316195423570985008687907853269984665640564039457584007913129639935",
              "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
              "1"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      mint_response = api_instance.create_developer_transaction_contract_execution(mint_request)

      print(json.dumps(mint_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "mintTo(address,uint256,string,uint256)",
          "abiParameters": [
            "<WALLET_ADDRESS>",
            "115792089237316195423570985008687907853269984665640564039457584007913129639935",
            "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
            "1"
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```

    <Note>
      **ERC-1155 Token ID Creation**: The first mint of each token ID requires
      passing the maximum uint256 value (`2^256 - 1` or
      `115792089237316195423570985008687907853269984665640564039457584007913129639935`)
      to create token ID 0 in the contract. For all subsequent mints, use `0` which
      creates the next sequential token ID (1, 2, 3, etc.). This is an ERC-1155
      standard requirement for lazy minting, where token IDs are created on demand
      rather than pre-initialized.
    </Note>

    ### Batch transfer tokens

    Use the `safeBatchTransferFrom` function to transfer multiple token types in a
    single transaction.

    <CodeGroup>
      ```ts Node.js theme={null}
      const transferResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature:
            "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
          abiParameters: [
            "<FROM_ADDRESS>",
            "<TO_ADDRESS>",
            ["0"], // Token IDs
            ["1"], // Amounts
            "0x", // Empty bytes
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(transferResponse.data, null, 2));
      ```

      ```python Python theme={null}
      transfer_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
          "abiParameters": [
              "<FROM_ADDRESS>",
              "<TO_ADDRESS>",
              ["0"],
              ["1"],
              "0x"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      transfer_response = api_instance.create_developer_transaction_contract_execution(transfer_request)

      print(json.dumps(transfer_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
          "abiParameters": [
            "<FROM_ADDRESS>",
            "<TO_ADDRESS>",
            ["0"],
            ["1"],
            "0x"
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    ### Complete script

    Here's the complete script combining mint and batch transfer operations:

    <CodeGroup>
      ```ts interact-erc1155.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      async function main() {
        // Mint tokens (token ID 0)
        const mintResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature: "mintTo(address,uint256,string,uint256)",
            abiParameters: [
              process.env.WALLET_ADDRESS,
              "115792089237316195423570985008687907853269984665640564039457584007913129639935", // Max uint256 = ID 0
              "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
              "1", // Amount
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(mintResponse.data, null, 2));

        // Batch transfer tokens
        const transferResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature:
              "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
            abiParameters: [
              process.env.WALLET_ADDRESS,
              process.env.RECIPIENT_WALLET_ADDRESS,
              ["0"], // Token IDs
              ["1"], // Amounts
              "0x", // Empty bytes
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(transferResponse.data, null, 2));
      }

      main();
      ```

      ```python interact_erc1155.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      # Mint tokens (token ID 0)
      mint_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "mintTo(address,uint256,string,uint256)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              "115792089237316195423570985008687907853269984665640564039457584007913129639935",
              "ipfs://bafkreibdi6623n3xpf7ymk62ckb4bo75o3qemwkpfvp5i25j66itxvsoei",
              "1"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      mint_response = api_instance.create_developer_transaction_contract_execution(mint_request)
      print(json.dumps(mint_response.data.to_dict(), indent=2))

      # Batch transfer tokens
      transfer_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)",
          "abiParameters": [
              os.getenv("WALLET_ADDRESS"),
              os.getenv("RECIPIENT_WALLET_ADDRESS"),
              ["0"],
              ["1"],
              "0x"
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      transfer_response = api_instance.create_developer_transaction_contract_execution(transfer_request)
      print(json.dumps(transfer_response.data.to_dict(), indent=2))
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run interact-erc1155
      ```

      ```shell Python theme={null}
      python interact_erc1155.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```
  </Tab>

  <Tab title="Airdrop">
    ## Execute airdrop operations

    The Airdrop contract enables mass token distribution to multiple recipients.

    ### Prerequisites

    Before executing an airdrop, you need:

    1. **A token contract address** - Deploy one using the
       [ERC-20](/arc/tutorials/deploy-contracts#erc-20),
       [ERC-721](/arc/tutorials/deploy-contracts#erc-721), or
       [ERC-1155](/arc/tutorials/deploy-contracts#erc-1155) templates, or use an
       existing token
    2. **Token balance** - Your wallet must hold enough tokens to distribute
    3. **Token approval** - Call the `approve` or `setApprovalForAll` function on
       your token contract to allow the airdrop contract to transfer tokens

    ### Execute an ERC-20 airdrop

    Use the `airdropERC20` function to distribute ERC-20 tokens to multiple
    recipients.

    <CodeGroup>
      ```ts Node.js theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      const airdropResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "airdropERC20(address,(address,uint256)[])",
          abiParameters: [
            "<TOKEN_CONTRACT_ADDRESS>", // ERC-20 token contract address
            [
              ["<RECIPIENT_ADDRESS_1>", "1000000000000000000"],
              ["<RECIPIENT_ADDRESS_2>", "2000000000000000000"],
            ],
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(airdropResponse.data, null, 2));
      ```

      ```python Python theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      airdrop_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "airdropERC20(address,(address,uint256)[])",
          "abiParameters": [
              "<TOKEN_CONTRACT_ADDRESS>",
              [
                  ["<RECIPIENT_ADDRESS_1>", "1000000000000000000"],
                  ["<RECIPIENT_ADDRESS_2>", "2000000000000000000"]
              ]
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      airdrop_response = api_instance.create_developer_transaction_contract_execution(airdrop_request)

      print(json.dumps(airdrop_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "airdropERC20(address,(address,uint256)[])",
          "abiParameters": [
            "<TOKEN_CONTRACT_ADDRESS>",
            [
              ["<RECIPIENT_ADDRESS_1>", "1000000000000000000"],
              ["<RECIPIENT_ADDRESS_2>", "2000000000000000000"]
            ]
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```

    <Note>
      **Token contract**: The first parameter is the address of the ERC-20 token
      contract you want to airdrop. You must deploy this contract first using the
      [Deploy contracts](/arc/tutorials/deploy-contracts) tutorial.
    </Note>

    ### Execute an ERC-721 airdrop

    Use the `airdropERC721` function to distribute tokens to multiple recipients.

    <CodeGroup>
      ```ts Node.js theme={null}
      const airdropResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "airdropERC721(address,(address,uint256)[])",
          abiParameters: [
            "<TOKEN_CONTRACT_ADDRESS>", // ERC-721 token contract address
            [
              ["<RECIPIENT_ADDRESS_1>", "1"], // Token ID 1
              ["<RECIPIENT_ADDRESS_2>", "2"], // Token ID 2
            ],
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(airdropResponse.data, null, 2));
      ```

      ```python Python theme={null}
      airdrop_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "airdropERC721(address,(address,uint256)[])",
          "abiParameters": [
              "<TOKEN_CONTRACT_ADDRESS>",
              [
                  ["<RECIPIENT_ADDRESS_1>", "1"],
                  ["<RECIPIENT_ADDRESS_2>", "2"]
              ]
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      airdrop_response = api_instance.create_developer_transaction_contract_execution(airdrop_request)

      print(json.dumps(airdrop_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "airdropERC721(address,(address,uint256)[])",
          "abiParameters": [
            "<TOKEN_CONTRACT_ADDRESS>",
            [
              ["<RECIPIENT_ADDRESS_1>", "1"],
              ["<RECIPIENT_ADDRESS_2>", "2"]
            ]
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```

    ### Execute an ERC-1155 airdrop

    Use the `airdropERC1155` function to distribute ERC-1155 tokens to multiple
    recipients.

    <CodeGroup>
      ```ts Node.js theme={null}
      const airdropResponse =
        await circleDeveloperSdk.createContractExecutionTransaction({
          walletId: process.env.WALLET_ID,
          abiFunctionSignature: "airdropERC1155(address,(address,uint256,uint256)[])",
          abiParameters: [
            "<TOKEN_CONTRACT_ADDRESS>", // ERC-1155 token contract address
            [
              ["<RECIPIENT_ADDRESS_1>", "0", "10"], // Token ID 0, amount 10
              ["<RECIPIENT_ADDRESS_2>", "1", "5"], // Token ID 1, amount 5
            ],
          ],
          contractAddress: process.env.CONTRACT_ADDRESS,
          fee: {
            type: "level",
            config: {
              feeLevel: "MEDIUM",
            },
          },
        });

      console.log(JSON.stringify(airdropResponse.data, null, 2));
      ```

      ```python Python theme={null}
      airdrop_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "airdropERC1155(address,(address,uint256,uint256)[])",
          "abiParameters": [
              "<TOKEN_CONTRACT_ADDRESS>",
              [
                  ["<RECIPIENT_ADDRESS_1>", "0", "10"],
                  ["<RECIPIENT_ADDRESS_2>", "1", "5"]
              ]
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      airdrop_response = api_instance.create_developer_transaction_contract_execution(airdrop_request)

      print(json.dumps(airdrop_response.data.to_dict(), indent=2))
      ```

      ```shell cURL theme={null}
      curl --request POST \
        --url 'https://api.circle.com/v1/w3s/developer/transactions/contractExecution' \
        --header 'authorization: Bearer <API_KEY>' \
        --header 'accept: application/json' \
        --header 'content-type: application/json' \
        --data '{
          "idempotencyKey": "<string>",
          "entitySecretCiphertext": "<string>",
          "walletId": "<WALLET_ID>",
          "abiFunctionSignature": "airdropERC1155(address,(address,uint256,uint256)[])",
          "abiParameters": [
            "<TOKEN_CONTRACT_ADDRESS>",
            [
              ["<RECIPIENT_ADDRESS_1>", "0", "10"],
              ["<RECIPIENT_ADDRESS_2>", "1", "5"]
            ]
          ],
          "contractAddress": "<CONTRACT_ADDRESS>",
          "feeLevel": "MEDIUM"
        }'
      ```
    </CodeGroup>

    ### Complete script

    Here's the complete script for executing an ERC-20 airdrop. You can adapt it for
    ERC-721 or ERC-1155 by changing the function signature and parameters as shown
    in the examples previously:

    <CodeGroup>
      ```ts interact-airdrop.ts theme={null}
      import { initiateDeveloperControlledWalletsClient } from "@circle-fin/developer-controlled-wallets";

      const circleDeveloperSdk = initiateDeveloperControlledWalletsClient({
        apiKey: process.env.CIRCLE_API_KEY,
        entitySecret: process.env.CIRCLE_ENTITY_SECRET,
      });

      async function main() {
        // Execute ERC-20 airdrop
        const airdropResponse =
          await circleDeveloperSdk.createContractExecutionTransaction({
            walletId: process.env.WALLET_ID,
            abiFunctionSignature: "airdropERC20(address,(address,uint256)[])",
            abiParameters: [
              process.env.TOKEN_CONTRACT_ADDRESS, // ERC-20 token contract address
              [
                [process.env.RECIPIENT_ADDRESS_1, "1000000000000000000"],
                [process.env.RECIPIENT_ADDRESS_2, "2000000000000000000"],
              ],
            ],
            contractAddress: process.env.CONTRACT_ADDRESS,
            fee: {
              type: "level",
              config: {
                feeLevel: "MEDIUM",
              },
            },
          });

        console.log(JSON.stringify(airdropResponse.data, null, 2));

        // For ERC-721 airdrop, use:
        // abiFunctionSignature: "airdropERC721(address,(address,uint256)[])"
        // abiParameters: [tokenAddress, [[recipient1, tokenId1], [recipient2, tokenId2]]]

        // For ERC-1155 airdrop, use:
        // abiFunctionSignature: "airdropERC1155(address,(address,uint256,uint256)[])"
        // abiParameters: [tokenAddress, [[recipient1, tokenId, amount], [recipient2, tokenId, amount]]]
      }

      main();
      ```

      ```python interact_airdrop.py theme={null}
      from circle.web3 import utils, developer_controlled_wallets
      import os
      import json

      client = utils.init_developer_controlled_wallets_client(
          api_key=os.getenv("CIRCLE_API_KEY"),
          entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
      )

      api_instance = developer_controlled_wallets.TransactionsApi(client)

      # Execute ERC-20 airdrop
      airdrop_request = developer_controlled_wallets.CreateContractExecutionTransactionForDeveloperRequest.from_dict({
          "walletId": os.getenv("WALLET_ID"),
          "abiFunctionSignature": "airdropERC20(address,(address,uint256)[])",
          "abiParameters": [
              os.getenv("TOKEN_CONTRACT_ADDRESS"),
              [
                  [os.getenv("RECIPIENT_ADDRESS_1"), "1000000000000000000"],
                  [os.getenv("RECIPIENT_ADDRESS_2"), "2000000000000000000"]
              ]
          ],
          "contractAddress": os.getenv("CONTRACT_ADDRESS"),
          "feeLevel": "MEDIUM",
      })

      airdrop_response = api_instance.create_developer_transaction_contract_execution(airdrop_request)
      print(json.dumps(airdrop_response.data.to_dict(), indent=2))

      # For ERC-721 airdrop, use:
      # abiFunctionSignature: "airdropERC721(address,(address,uint256)[])"
      # abiParameters: [token_address, [[recipient1, token_id1], [recipient2, token_id2]]]

      # For ERC-1155 airdrop, use:
      # abiFunctionSignature: "airdropERC1155(address,(address,uint256,uint256)[])"
      # abiParameters: [token_address, [[recipient1, token_id, amount], [recipient2, token_id, amount]]]
      ```
    </CodeGroup>

    **Run the script:**

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run interact-airdrop
      ```

      ```shell Python theme={null}
      python interact_airdrop.py
      ```
    </CodeGroup>

    **Response:**

    ```json  theme={null}
    {
      "id": "601a0815-f749-41d8-b193-22cadd2a8977",
      "state": "INITIATED"
    }
    ```
  </Tab>
</Tabs>

***

## Summary

After completing this tutorial, you've learned how to:

* Execute contract functions using the Circle SDKs
* Mint and transfer tokens for your deployed contracts
* Perform contract-specific operations based on token type


> ## Documentation Index
> Fetch the complete documentation index at: https://docs.arc.network/llms.txt
> Use this file to discover all available pages before exploring further.

# Monitor contract events

> Track onchain activity by monitoring contract events.

Track contract events and get event logs with the Circle Contracts API.

## Prerequisites

Complete the [Deploy contracts](/arc/tutorials/deploy-contracts) tutorial first.
You'll need a deployed contract.

## Set up npm scripts

If you haven't already, add run scripts for monitoring contract events to your
`package.json`:

```shell  theme={null}
npm pkg set scripts.webhook="tsx webhook-receiver.ts"
npm pkg set scripts.import-contract="tsx --env-file=.env import-contract.ts"
npm pkg set scripts.create-monitor="tsx --env-file=.env create-monitor.ts"
npm pkg set scripts.get-event-logs="tsx --env-file=.env get-event-logs.ts"
```

<Note>
  If you completed the Deploy contracts tutorial, your project already has the
  required SDKs installed. The npm scripts previously listed work with your
  existing setup.
</Note>

## Step 1: Set up a webhook endpoint

Event monitors send real-time updates to your webhook endpoint when events
happen.

<Tabs>
  <Tab title="webhook.site">
    1. Visit [webhook.site](https://webhook.site)
    2. Copy your unique webhook URL (for example, `https://webhook.site/your-uuid`)
  </Tab>

  <Tab title="ngrok">
    1. Install `ngrok` from [ngrok.com](https://ngrok.com)

    2. Create a webhook receiver script:

    <CodeGroup>
      ```ts webhook-receiver.ts theme={null}
      import express, { Request, Response } from "express";

      const app = express();
      app.use(express.json());

      app.post("/webhook", (req: Request, res: Response) => {
        console.log("Received webhook:");
        console.log(JSON.stringify(req.body, null, 2));
        res.status(200).json({ received: true });
      });

      const PORT = 3000;
      app.listen(PORT, () => {
        console.log(`Webhook receiver listening on port ${PORT}`);
        console.log(`Endpoint: http://localhost:${PORT}/webhook`);
      });
      ```

      ```python webhook_receiver.py theme={null}
      from flask import Flask, request, jsonify
      import json

      app = Flask(__name__)

      @app.route("/webhook", methods=["POST"])
      def webhook():
          data = request.get_json()
          print("Received webhook:")
          print(json.dumps(data, indent=2))
          return jsonify({"received": True}), 200

      if __name__ == "__main__":
          PORT = 3000
          print(f"Webhook receiver listening on port {PORT}")
          print(f"Endpoint: http://localhost:{PORT}/webhook")
          app.run(port=PORT)
      ```
    </CodeGroup>

    3. Start the webhook receiver:

    <CodeGroup>
      ```shell Node.js theme={null}
      npm run webhook
      ```

      ```shell Python theme={null}
      python webhook_receiver.py
      ```
    </CodeGroup>

    4. In a separate terminal, start `ngrok`:

    ```shell  theme={null}
    ngrok http 3000
    ```

    5. Copy the HTTPS forwarding URL (for example,
       `https://abc123.ngrok-free.app/webhook`)

    <Note>
      If using `ngrok` for local testing, you can optionally set `WEBHOOK_URL` in
      your `.env` file to store your `ngrok` forwarding URL.
    </Note>
  </Tab>
</Tabs>

## Step 2: Register your webhook in Console

Register your webhook URL in the Developer Console:

1. Go to [Developer Console](https://console.circle.com)
2. Navigate to **Webhooks** (left sidebar)
3. Click **Add a webhook**
4. Enter your webhook URL (from Step 1) and create the webhook

<Note>
  Register your webhook before creating event monitors. This allows Circle to
  send notifications to your endpoint.
</Note>

## Step 3: Import an existing contract (optional)

If you already have a deployed contract and want to monitor its events, import
it to the Developer Console. If you deployed a contract using Circle Contracts
(for example, in the [Deploy contracts](/arc/tutorials/deploy-contracts)
tutorial), skip this step. Your contract is already available in the Console.

<CodeGroup>
  ```ts import-contract.ts theme={null}
  import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

  const contractClient = initiateSmartContractPlatformClient({
    apiKey: process.env.CIRCLE_API_KEY,
    entitySecret: process.env.CIRCLE_ENTITY_SECRET,
  });

  async function importContract() {
    try {
      const response = await contractClient.importContract({
        blockchain: "ARC-TESTNET",
        address: process.env.CONTRACT_ADDRESS,
        name: "MyContract",
      });

      console.log(JSON.stringify(response.data, null, 2));
    } catch (error) {
      console.error("Error importing contract:", error.message);
      throw error;
    }
  }

  importContract();
  ```

  ```python import_contract.py theme={null}
  from circle.web3 import utils, smart_contract_platform
  import os
  import json

  client = utils.init_smart_contract_platform_client(
      api_key=os.getenv("CIRCLE_API_KEY"),
      entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
  )

  def import_contract():
      try:
          contracts_api = smart_contract_platform.ContractsApi(client)
          import_request = smart_contract_platform.ImportContractRequest(
              blockchain="ARC-TESTNET",
              address=os.getenv("CONTRACT_ADDRESS"),
              name="MyContract",
          )

          response = contracts_api.import_contract(import_contract_request=import_request)

          print(json.dumps(response.data.to_dict(), indent=2))

      except Exception as error:
          print(f"Error importing contract: {error}")
          raise error

  import_contract()
  ```
</CodeGroup>

**Run the script:**

<CodeGroup>
  ```shell Node.js theme={null}
  npm run import-contract
  ```

  ```shell Python theme={null}
  python import_contract.py
  ```
</CodeGroup>

<Note>
  If the contract is already imported, you'll see an error: `contract already
    exists`. This means the contract is already available in the Console and you
  can proceed to create an event monitor.
</Note>

## Step 4: Create an event monitor

Event monitors track specific contract events. They send updates to your webhook
endpoint. This example monitors `Transfer` events:

<CodeGroup>
  ```ts create-monitor.ts theme={null}
  import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

  const contractClient = initiateSmartContractPlatformClient({
    apiKey: process.env.CIRCLE_API_KEY,
    entitySecret: process.env.CIRCLE_ENTITY_SECRET,
  });

  async function createEventMonitor() {
    try {
      const response = await contractClient.createEventMonitor({
        blockchain: "ARC-TESTNET",
        contractAddress: process.env.CONTRACT_ADDRESS,
        eventSignature: "Transfer(address,address,uint256)",
      });

      console.log(JSON.stringify(response.data, null, 2));
    } catch (error) {
      console.error("Error creating event monitor:", error.message);
      throw error;
    }
  }

  createEventMonitor();
  ```

  ```python create_monitor.py theme={null}
  from circle.web3 import utils, smart_contract_platform
  import os
  import json

  client = utils.init_smart_contract_platform_client(
      api_key=os.getenv("CIRCLE_API_KEY"),
      entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
  )

  def create_event_monitor():
      try:
          event_monitors_api = smart_contract_platform.EventMonitorsApi(client)
          monitor_request = smart_contract_platform.CreateEventMonitorRequest(
              blockchain="ARC-TESTNET",
              contract_address=os.getenv("CONTRACT_ADDRESS"),
              event_signature="Transfer(address,address,uint256)",
          )

          response = event_monitors_api.create_event_monitor(
              create_event_monitor_request=monitor_request
          )

          print(json.dumps(response.data.to_dict(), indent=2))
      except Exception as error:
          print(f"Error creating event monitor: {error}")
          raise

  create_event_monitor()
  ```
</CodeGroup>

**Run the script:**

<CodeGroup>
  ```shell Node.js theme={null}
  npm run create-monitor
  ```

  ```shell Python theme={null}
  python create_monitor.py
  ```
</CodeGroup>

**Response:**

```json  theme={null}
{
  "eventMonitor": {
    "id": "019bf984-b4da-7026-a3d2-674ce371a933",
    "contractName": "TestERC20Token",
    "contractId": "019bf8be-7be5-7a3e-89cc-05bcd7413f20",
    "contractAddress": "0x281156899e5bd6fecf1c0831ee24894eeeaea2f8",
    "blockchain": "ARC-TESTNET",
    "eventSignature": "Transfer(address,address,uint256)",
    "eventSignatureHash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
    "isEnabled": true,
    "createDate": "2026-01-26T08:56:22.490638Z",
    "updateDate": "2026-01-26T08:56:22.490638Z"
  }
}
```

## Step 5: Receive webhook notifications

When events occur, Circle sends updates to your endpoint. Here is what a
`Transfer` event looks like:

```json  theme={null}
{
  "subscriptionId": "f0332621-a117-4b7b-bdf0-5c61a4681826",
  "notificationId": "5c5eea9f-398f-426f-a4a5-1bdc28b36d2c",
  "notificationType": "contracts.eventLog",
  "notification": {
    "contractAddress": "0x4abcffb90897fe7ce86ed689d1178076544a021b",
    "blockchain": "ARC-TESTNET",
    "txHash": "0xe15d6dbb50178f60930b8a3e3e775f3c022505ea2e351b6c2c2985d2405c8ebc",
    "userOpHash": "0x78c3e8185ff9abfc7197a8432d9b79566123616c136001e609102c97e732e55e",
    "blockHash": "0x0ad6bf57a110d42620defbcb9af98d6223f060de588ed96ae495ddeaf3565c8d",
    "blockHeight": 22807198,
    "eventSignature": "Transfer(address,address,uint256)",
    "eventSignatureHash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
    "topics": [
      "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
      "0x0000000000000000000000000000000000000000000000000000000000000000",
      "0x000000000000000000000000bcf83d3b112cbf43b19904e376dd8dee01fe2758"
    ],
    "data": "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000",
    "firstConfirmDate": "2026-01-21T06:53:12Z"
  },
  "timestamp": "2026-01-21T06:53:13.194467201Z",
  "version": 2
}
```

**Key fields:**

* `notificationType`: Always `"contracts.eventLog"` for event monitor webhooks
* `notification.eventSignature`: The event that was emitted
* `notification.contractAddress`: Address of the contract that emitted the event
* `notification.blockchain`: The blockchain network (for example, `ARC-TESTNET`)
* `notification.txHash`: Transaction hash where the event occurred
* `notification.userOpHash`: User operation hash (for smart contract accounts)
* `notification.blockHash`: Hash of the block containing the transaction
* `notification.blockHeight`: Block number where the event occurred
* `notification.eventSignatureHash`: Keccak256 hash of the event signature
* `notification.topics`: Indexed event parameters (for example, `from` and `to`
  addresses)
* `notification.data`: Non-indexed event parameters (for example, token amount)
* `notification.firstConfirmDate`: Timestamp when the event was first confirmed
* `timestamp`: Timestamp when the webhook was sent
* `version`: Webhook payload version

<Tip>
  You can verify webhook delivery status in the [Developer
  Console](https://console.circle.com) under Contracts → Monitoring.
</Tip>

## Step 6: Retrieve event logs

You can also query event logs with the API. This is useful for past events or if
you prefer polling.

<Note>
  **Webhooks vs Polling**: Webhooks send real-time updates (push). Polling needs
  periodic API calls (pull). Use webhooks for production and polling for testing
  or past queries.
</Note>

<CodeGroup>
  ```ts get-event-logs.ts theme={null}
  import { initiateSmartContractPlatformClient } from "@circle-fin/smart-contract-platform";

  const contractClient = initiateSmartContractPlatformClient({
    apiKey: process.env.CIRCLE_API_KEY,
    entitySecret: process.env.CIRCLE_ENTITY_SECRET,
  });

  async function getEventLogs() {
    try {
      const response = await contractClient.listEventLogs({
        contractAddress: process.env.CONTRACT_ADDRESS,
        blockchain: "ARC-TESTNET",
        pageSize: 10,
      });

      console.log(JSON.stringify(response.data, null, 2));
    } catch (error) {
      console.error("Error fetching event logs:", error.message);
      throw error;
    }
  }

  getEventLogs();
  ```

  ```python get_event_logs.py theme={null}
  from circle.web3 import utils, smart_contract_platform
  import os
  import json

  client = utils.init_smart_contract_platform_client(
      api_key=os.getenv("CIRCLE_API_KEY"),
      entity_secret=os.getenv("CIRCLE_ENTITY_SECRET")
  )

  event_monitors_api = smart_contract_platform.EventMonitorsApi(client)

  def get_event_logs():
      try:
          response = event_monitors_api.list_event_logs(
              contract_address=os.getenv("CONTRACT_ADDRESS"),
              blockchain="ARC-TESTNET",
              page_size=10
          )

          print(json.dumps(response.data.to_dict(), indent=2, default=str))

      except Exception as error:
          print(f"Error fetching event logs: {error}")
          raise

  get_event_logs()
  ```
</CodeGroup>

**Run the script:**

<CodeGroup>
  ```shell Node.js theme={null}
  npm run get-event-logs
  ```

  ```shell Python theme={null}
  python get_event_logs.py
  ```
</CodeGroup>

<Note>
  Replace `CONTRACT_ADDRESS` with your contract address. You can get this
  address when you deploy the contract, or by listing your contracts with
  `listContracts()`.
</Note>

**Response:**

```json  theme={null}
{
  "eventLogs": [
    {
      "id": "019bf987-f901-7145-9e95-55f177b05b24",
      "subscriptionId": "019bf984-b4da-7026-a3d2-674ce371a933",
      "contractId": "019bf8be-7be5-7a3e-89cc-05bcd7413f20",
      "contractName": "TestERC20Token",
      "blockchain": "ARC-TESTNET",
      "txHash": "0x3bfbab5d5ce0d1a5d682cbc742d3940cf59db0369d173b71ba2a3b8f43bfbcb1",
      "logIndex": "50",
      "blockHash": "0x7d12148f9331556b31f84f58a41b7ff16eaaa47940f9e86733037d7ab74d858e",
      "blockHeight": 23686153,
      "contractAddress": "0x281156899e5bd6fecf1c0831ee24894eeeaea2f8",
      "eventSignature": "Transfer(address,address,uint256)",
      "eventSignatureHash": "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
      "topics": [
        "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef",
        "0x0000000000000000000000000000000000000000000000000000000000000000",
        "0x000000000000000000000000bcf83d3b112cbf43b19904e376dd8dee01fe2758"
      ],
      "data": "0x0000000000000000000000000000000000000000000000000de0b6b3a7640000",
      "decodedTopics": null,
      "decodedData": null,
      "userOpHash": "0x66befac1a371fcdddf1566215e4677127e111dff9253f306f7096fed8642a208",
      "firstConfirmDate": "2026-01-26T08:59:55Z",
      "createDate": "2026-01-26T08:59:56.545962Z",
      "updateDate": "2026-01-26T08:59:56.545962Z"
    }
  ]
}
```

<Note>
  You can view, update, and delete event monitors with the Circle Contracts API.
  See the [API
  Reference](https://developers.circle.com/api-reference/contracts/smart-contract-platform/list-event-monitors)
  for details on managing your monitors.
</Note>

## Summary

After completing this tutorial, you've successfully:

* Set up webhook endpoints using webhook.site or `ngrok`
* Registered webhooks in the Developer Console
* Created event monitors for specific contract events
* Received real-time webhook updates for contract events
* Retrieved past event logs with the Circle SDK


More docs will be provided on demand:
References
Contract Addresses
Gas and Fees
Key Features
Stable Fee Design
Deterministic Finality
Opt-in Privacy
Architecture
System Overview
Consensus Layer
Execution Layer
EVM Compatibility
Tools
Account Abstraction
Block Explorers
Compliance
Data Indexers
Node Providers